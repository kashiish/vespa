// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: google/analytics/data/v1beta/analytics_data_api.proto
// Original file comments:
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#ifndef GRPC_google_2fanalytics_2fdata_2fv1beta_2fanalytics_5fdata_5fapi_2eproto__INCLUDED
#define GRPC_google_2fanalytics_2fdata_2fv1beta_2fanalytics_5fdata_5fapi_2eproto__INCLUDED

#include "google/analytics/data/v1beta/analytics_data_api.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace google {
namespace analytics {
namespace data {
namespace v1beta {

// Google Analytics reporting data service.
class BetaAnalyticsData final {
 public:
  static constexpr char const* service_full_name() {
    return "google.analytics.data.v1beta.BetaAnalyticsData";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Returns a customized report of your Google Analytics event data. Reports
    // contain statistics derived from data collected by the Google Analytics
    // tracking code. The data returned from the API is as a table with columns
    // for the requested dimensions and metrics. Metrics are individual
    // measurements of user activity on your property, such as active users or
    // event count. Dimensions break down metrics across some common criteria,
    // such as country or event name.
    virtual ::grpc::Status RunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::google::analytics::data::v1beta::RunReportResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunReportResponse>> AsyncRunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunReportResponse>>(AsyncRunReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunReportResponse>> PrepareAsyncRunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunReportResponse>>(PrepareAsyncRunReportRaw(context, request, cq));
    }
    // Returns a customized pivot report of your Google Analytics event data.
    // Pivot reports are more advanced and expressive formats than regular
    // reports. In a pivot report, dimensions are only visible if they are
    // included in a pivot. Multiple pivots can be specified to further dissect
    // your data.
    virtual ::grpc::Status RunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::google::analytics::data::v1beta::RunPivotReportResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunPivotReportResponse>> AsyncRunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunPivotReportResponse>>(AsyncRunPivotReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunPivotReportResponse>> PrepareAsyncRunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunPivotReportResponse>>(PrepareAsyncRunPivotReportRaw(context, request, cq));
    }
    // Returns multiple reports in a batch. All reports must be for the same
    // GA4 Property.
    virtual ::grpc::Status BatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunReportsResponse>> AsyncBatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunReportsResponse>>(AsyncBatchRunReportsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunReportsResponse>> PrepareAsyncBatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunReportsResponse>>(PrepareAsyncBatchRunReportsRaw(context, request, cq));
    }
    // Returns multiple pivot reports in a batch. All reports must be for the same
    // GA4 Property.
    virtual ::grpc::Status BatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>> AsyncBatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>>(AsyncBatchRunPivotReportsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>> PrepareAsyncBatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>>(PrepareAsyncBatchRunPivotReportsRaw(context, request, cq));
    }
    // Returns metadata for dimensions and metrics available in reporting methods.
    // Used to explore the dimensions and metrics. In this method, a Google
    // Analytics GA4 Property Identifier is specified in the request, and
    // the metadata response includes Custom dimensions and metrics as well as
    // Universal metadata.
    //
    // For example if a custom metric with parameter name `levels_unlocked` is
    // registered to a property, the Metadata response will contain
    // `customEvent:levels_unlocked`. Universal metadata are dimensions and
    // metrics applicable to any property such as `country` and `totalUsers`.
    virtual ::grpc::Status GetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::google::analytics::data::v1beta::Metadata* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::Metadata>> AsyncGetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::Metadata>>(AsyncGetMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::Metadata>> PrepareAsyncGetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::Metadata>>(PrepareAsyncGetMetadataRaw(context, request, cq));
    }
    // The Google Analytics Realtime API returns a customized report of realtime
    // event data for your property. These reports show events and usage from the
    // last 30 minutes.
    virtual ::grpc::Status RunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunRealtimeReportResponse>> AsyncRunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunRealtimeReportResponse>>(AsyncRunRealtimeReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunRealtimeReportResponse>> PrepareAsyncRunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunRealtimeReportResponse>>(PrepareAsyncRunRealtimeReportRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Returns a customized report of your Google Analytics event data. Reports
      // contain statistics derived from data collected by the Google Analytics
      // tracking code. The data returned from the API is as a table with columns
      // for the requested dimensions and metrics. Metrics are individual
      // measurements of user activity on your property, such as active users or
      // event count. Dimensions break down metrics across some common criteria,
      // such as country or event name.
      virtual void RunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest* request, ::google::analytics::data::v1beta::RunReportResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest* request, ::google::analytics::data::v1beta::RunReportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns a customized pivot report of your Google Analytics event data.
      // Pivot reports are more advanced and expressive formats than regular
      // reports. In a pivot report, dimensions are only visible if they are
      // included in a pivot. Multiple pivots can be specified to further dissect
      // your data.
      virtual void RunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::google::analytics::data::v1beta::RunPivotReportResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::google::analytics::data::v1beta::RunPivotReportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns multiple reports in a batch. All reports must be for the same
      // GA4 Property.
      virtual void BatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns multiple pivot reports in a batch. All reports must be for the same
      // GA4 Property.
      virtual void BatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns metadata for dimensions and metrics available in reporting methods.
      // Used to explore the dimensions and metrics. In this method, a Google
      // Analytics GA4 Property Identifier is specified in the request, and
      // the metadata response includes Custom dimensions and metrics as well as
      // Universal metadata.
      //
      // For example if a custom metric with parameter name `levels_unlocked` is
      // registered to a property, the Metadata response will contain
      // `customEvent:levels_unlocked`. Universal metadata are dimensions and
      // metrics applicable to any property such as `country` and `totalUsers`.
      virtual void GetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest* request, ::google::analytics::data::v1beta::Metadata* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest* request, ::google::analytics::data::v1beta::Metadata* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // The Google Analytics Realtime API returns a customized report of realtime
      // event data for your property. These reports show events and usage from the
      // last 30 minutes.
      virtual void RunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunReportResponse>* AsyncRunReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunReportResponse>* PrepareAsyncRunReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunPivotReportResponse>* AsyncRunPivotReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunPivotReportResponse>* PrepareAsyncRunPivotReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunReportsResponse>* AsyncBatchRunReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunReportsResponse>* PrepareAsyncBatchRunReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* AsyncBatchRunPivotReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* PrepareAsyncBatchRunPivotReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::Metadata>* AsyncGetMetadataRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::Metadata>* PrepareAsyncGetMetadataRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunRealtimeReportResponse>* AsyncRunRealtimeReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::analytics::data::v1beta::RunRealtimeReportResponse>* PrepareAsyncRunRealtimeReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status RunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::google::analytics::data::v1beta::RunReportResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunReportResponse>> AsyncRunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunReportResponse>>(AsyncRunReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunReportResponse>> PrepareAsyncRunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunReportResponse>>(PrepareAsyncRunReportRaw(context, request, cq));
    }
    ::grpc::Status RunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::google::analytics::data::v1beta::RunPivotReportResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunPivotReportResponse>> AsyncRunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunPivotReportResponse>>(AsyncRunPivotReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunPivotReportResponse>> PrepareAsyncRunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunPivotReportResponse>>(PrepareAsyncRunPivotReportRaw(context, request, cq));
    }
    ::grpc::Status BatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunReportsResponse>> AsyncBatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunReportsResponse>>(AsyncBatchRunReportsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunReportsResponse>> PrepareAsyncBatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunReportsResponse>>(PrepareAsyncBatchRunReportsRaw(context, request, cq));
    }
    ::grpc::Status BatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>> AsyncBatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>>(AsyncBatchRunPivotReportsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>> PrepareAsyncBatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>>(PrepareAsyncBatchRunPivotReportsRaw(context, request, cq));
    }
    ::grpc::Status GetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::google::analytics::data::v1beta::Metadata* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::Metadata>> AsyncGetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::Metadata>>(AsyncGetMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::Metadata>> PrepareAsyncGetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::Metadata>>(PrepareAsyncGetMetadataRaw(context, request, cq));
    }
    ::grpc::Status RunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunRealtimeReportResponse>> AsyncRunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunRealtimeReportResponse>>(AsyncRunRealtimeReportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunRealtimeReportResponse>> PrepareAsyncRunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunRealtimeReportResponse>>(PrepareAsyncRunRealtimeReportRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void RunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest* request, ::google::analytics::data::v1beta::RunReportResponse* response, std::function<void(::grpc::Status)>) override;
      void RunReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest* request, ::google::analytics::data::v1beta::RunReportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::google::analytics::data::v1beta::RunPivotReportResponse* response, std::function<void(::grpc::Status)>) override;
      void RunPivotReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::google::analytics::data::v1beta::RunPivotReportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchRunReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchRunPivotReports(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest* request, ::google::analytics::data::v1beta::Metadata* response, std::function<void(::grpc::Status)>) override;
      void GetMetadata(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest* request, ::google::analytics::data::v1beta::Metadata* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response, std::function<void(::grpc::Status)>) override;
      void RunRealtimeReport(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunReportResponse>* AsyncRunReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunReportResponse>* PrepareAsyncRunReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunPivotReportResponse>* AsyncRunPivotReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunPivotReportResponse>* PrepareAsyncRunPivotReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunReportsResponse>* AsyncBatchRunReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunReportsResponse>* PrepareAsyncBatchRunReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* AsyncBatchRunPivotReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* PrepareAsyncBatchRunPivotReportsRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::Metadata>* AsyncGetMetadataRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::Metadata>* PrepareAsyncGetMetadataRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunRealtimeReportResponse>* AsyncRunRealtimeReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::analytics::data::v1beta::RunRealtimeReportResponse>* PrepareAsyncRunRealtimeReportRaw(::grpc::ClientContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RunReport_;
    const ::grpc::internal::RpcMethod rpcmethod_RunPivotReport_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchRunReports_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchRunPivotReports_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_RunRealtimeReport_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Returns a customized report of your Google Analytics event data. Reports
    // contain statistics derived from data collected by the Google Analytics
    // tracking code. The data returned from the API is as a table with columns
    // for the requested dimensions and metrics. Metrics are individual
    // measurements of user activity on your property, such as active users or
    // event count. Dimensions break down metrics across some common criteria,
    // such as country or event name.
    virtual ::grpc::Status RunReport(::grpc::ServerContext* context, const ::google::analytics::data::v1beta::RunReportRequest* request, ::google::analytics::data::v1beta::RunReportResponse* response);
    // Returns a customized pivot report of your Google Analytics event data.
    // Pivot reports are more advanced and expressive formats than regular
    // reports. In a pivot report, dimensions are only visible if they are
    // included in a pivot. Multiple pivots can be specified to further dissect
    // your data.
    virtual ::grpc::Status RunPivotReport(::grpc::ServerContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::google::analytics::data::v1beta::RunPivotReportResponse* response);
    // Returns multiple reports in a batch. All reports must be for the same
    // GA4 Property.
    virtual ::grpc::Status BatchRunReports(::grpc::ServerContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response);
    // Returns multiple pivot reports in a batch. All reports must be for the same
    // GA4 Property.
    virtual ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response);
    // Returns metadata for dimensions and metrics available in reporting methods.
    // Used to explore the dimensions and metrics. In this method, a Google
    // Analytics GA4 Property Identifier is specified in the request, and
    // the metadata response includes Custom dimensions and metrics as well as
    // Universal metadata.
    //
    // For example if a custom metric with parameter name `levels_unlocked` is
    // registered to a property, the Metadata response will contain
    // `customEvent:levels_unlocked`. Universal metadata are dimensions and
    // metrics applicable to any property such as `country` and `totalUsers`.
    virtual ::grpc::Status GetMetadata(::grpc::ServerContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest* request, ::google::analytics::data::v1beta::Metadata* response);
    // The Google Analytics Realtime API returns a customized report of realtime
    // event data for your property. These reports show events and usage from the
    // last 30 minutes.
    virtual ::grpc::Status RunRealtimeReport(::grpc::ServerContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_RunReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RunReport() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RunReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunReport(::grpc::ServerContext* context, ::google::analytics::data::v1beta::RunReportRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::analytics::data::v1beta::RunReportResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunPivotReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RunPivotReport() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RunPivotReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPivotReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunPivotReport(::grpc::ServerContext* context, ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::analytics::data::v1beta::RunPivotReportResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchRunReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchRunReports() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_BatchRunReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchRunReports(::grpc::ServerContext* context, ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::analytics::data::v1beta::BatchRunReportsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchRunPivotReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchRunPivotReports() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_BatchRunPivotReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchRunPivotReports(::grpc::ServerContext* context, ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMetadata() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMetadata(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMetadata(::grpc::ServerContext* context, ::google::analytics::data::v1beta::GetMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::analytics::data::v1beta::Metadata>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunRealtimeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RunRealtimeReport() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_RunRealtimeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunRealtimeReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunRealtimeReport(::grpc::ServerContext* context, ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::analytics::data::v1beta::RunRealtimeReportResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RunReport<WithAsyncMethod_RunPivotReport<WithAsyncMethod_BatchRunReports<WithAsyncMethod_BatchRunPivotReports<WithAsyncMethod_GetMetadata<WithAsyncMethod_RunRealtimeReport<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_RunReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RunReport() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::RunReportRequest, ::google::analytics::data::v1beta::RunReportResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::analytics::data::v1beta::RunReportRequest* request, ::google::analytics::data::v1beta::RunReportResponse* response) { return this->RunReport(context, request, response); }));}
    void SetMessageAllocatorFor_RunReport(
        ::grpc::MessageAllocator< ::google::analytics::data::v1beta::RunReportRequest, ::google::analytics::data::v1beta::RunReportResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::RunReportRequest, ::google::analytics::data::v1beta::RunReportResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RunReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunReport(
      ::grpc::CallbackServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RunPivotReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RunPivotReport() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::RunPivotReportRequest, ::google::analytics::data::v1beta::RunPivotReportResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::analytics::data::v1beta::RunPivotReportRequest* request, ::google::analytics::data::v1beta::RunPivotReportResponse* response) { return this->RunPivotReport(context, request, response); }));}
    void SetMessageAllocatorFor_RunPivotReport(
        ::grpc::MessageAllocator< ::google::analytics::data::v1beta::RunPivotReportRequest, ::google::analytics::data::v1beta::RunPivotReportResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::RunPivotReportRequest, ::google::analytics::data::v1beta::RunPivotReportResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RunPivotReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPivotReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunPivotReport(
      ::grpc::CallbackServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchRunReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchRunReports() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::BatchRunReportsRequest, ::google::analytics::data::v1beta::BatchRunReportsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::analytics::data::v1beta::BatchRunReportsRequest* request, ::google::analytics::data::v1beta::BatchRunReportsResponse* response) { return this->BatchRunReports(context, request, response); }));}
    void SetMessageAllocatorFor_BatchRunReports(
        ::grpc::MessageAllocator< ::google::analytics::data::v1beta::BatchRunReportsRequest, ::google::analytics::data::v1beta::BatchRunReportsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::BatchRunReportsRequest, ::google::analytics::data::v1beta::BatchRunReportsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchRunReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchRunReports(
      ::grpc::CallbackServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchRunPivotReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchRunPivotReports() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::BatchRunPivotReportsRequest, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* request, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* response) { return this->BatchRunPivotReports(context, request, response); }));}
    void SetMessageAllocatorFor_BatchRunPivotReports(
        ::grpc::MessageAllocator< ::google::analytics::data::v1beta::BatchRunPivotReportsRequest, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::BatchRunPivotReportsRequest, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchRunPivotReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchRunPivotReports(
      ::grpc::CallbackServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMetadata() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::GetMetadataRequest, ::google::analytics::data::v1beta::Metadata>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::analytics::data::v1beta::GetMetadataRequest* request, ::google::analytics::data::v1beta::Metadata* response) { return this->GetMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_GetMetadata(
        ::grpc::MessageAllocator< ::google::analytics::data::v1beta::GetMetadataRequest, ::google::analytics::data::v1beta::Metadata>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::GetMetadataRequest, ::google::analytics::data::v1beta::Metadata>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMetadata(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RunRealtimeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RunRealtimeReport() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::RunRealtimeReportRequest, ::google::analytics::data::v1beta::RunRealtimeReportResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* request, ::google::analytics::data::v1beta::RunRealtimeReportResponse* response) { return this->RunRealtimeReport(context, request, response); }));}
    void SetMessageAllocatorFor_RunRealtimeReport(
        ::grpc::MessageAllocator< ::google::analytics::data::v1beta::RunRealtimeReportRequest, ::google::analytics::data::v1beta::RunRealtimeReportResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::analytics::data::v1beta::RunRealtimeReportRequest, ::google::analytics::data::v1beta::RunRealtimeReportResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RunRealtimeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunRealtimeReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunRealtimeReport(
      ::grpc::CallbackServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_RunReport<WithCallbackMethod_RunPivotReport<WithCallbackMethod_BatchRunReports<WithCallbackMethod_BatchRunPivotReports<WithCallbackMethod_GetMetadata<WithCallbackMethod_RunRealtimeReport<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RunReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RunReport() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RunReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunPivotReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RunPivotReport() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RunPivotReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPivotReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchRunReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchRunReports() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_BatchRunReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchRunPivotReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchRunPivotReports() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_BatchRunPivotReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMetadata() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMetadata(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunRealtimeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RunRealtimeReport() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_RunRealtimeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunRealtimeReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RunReport() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RunReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunReport(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunPivotReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RunPivotReport() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RunPivotReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPivotReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunPivotReport(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchRunReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchRunReports() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_BatchRunReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchRunReports(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchRunPivotReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchRunPivotReports() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_BatchRunPivotReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchRunPivotReports(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMetadata() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMetadata(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunRealtimeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RunRealtimeReport() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_RunRealtimeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunRealtimeReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunRealtimeReport(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RunReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RunReport() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RunReport(context, request, response); }));
    }
    ~WithRawCallbackMethod_RunReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunReport(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RunPivotReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RunPivotReport() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RunPivotReport(context, request, response); }));
    }
    ~WithRawCallbackMethod_RunPivotReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPivotReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunPivotReport(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchRunReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchRunReports() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchRunReports(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchRunReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchRunReports(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchRunPivotReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchRunPivotReports() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchRunPivotReports(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchRunPivotReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchRunPivotReports(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMetadata() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMetadata(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RunRealtimeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RunRealtimeReport() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RunRealtimeReport(context, request, response); }));
    }
    ~WithRawCallbackMethod_RunRealtimeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunRealtimeReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunRealtimeReport(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RunReport() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::analytics::data::v1beta::RunReportRequest, ::google::analytics::data::v1beta::RunReportResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::analytics::data::v1beta::RunReportRequest, ::google::analytics::data::v1beta::RunReportResponse>* streamer) {
                       return this->StreamedRunReport(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RunReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunReportRequest* /*request*/, ::google::analytics::data::v1beta::RunReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunReport(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::analytics::data::v1beta::RunReportRequest,::google::analytics::data::v1beta::RunReportResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunPivotReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RunPivotReport() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::analytics::data::v1beta::RunPivotReportRequest, ::google::analytics::data::v1beta::RunPivotReportResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::analytics::data::v1beta::RunPivotReportRequest, ::google::analytics::data::v1beta::RunPivotReportResponse>* streamer) {
                       return this->StreamedRunPivotReport(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RunPivotReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunPivotReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunPivotReportRequest* /*request*/, ::google::analytics::data::v1beta::RunPivotReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunPivotReport(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::analytics::data::v1beta::RunPivotReportRequest,::google::analytics::data::v1beta::RunPivotReportResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchRunReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchRunReports() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::analytics::data::v1beta::BatchRunReportsRequest, ::google::analytics::data::v1beta::BatchRunReportsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::analytics::data::v1beta::BatchRunReportsRequest, ::google::analytics::data::v1beta::BatchRunReportsResponse>* streamer) {
                       return this->StreamedBatchRunReports(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchRunReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchRunReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchRunReports(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::analytics::data::v1beta::BatchRunReportsRequest,::google::analytics::data::v1beta::BatchRunReportsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchRunPivotReports : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchRunPivotReports() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::analytics::data::v1beta::BatchRunPivotReportsRequest, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::analytics::data::v1beta::BatchRunPivotReportsRequest, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* streamer) {
                       return this->StreamedBatchRunPivotReports(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchRunPivotReports() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchRunPivotReports(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::BatchRunPivotReportsRequest* /*request*/, ::google::analytics::data::v1beta::BatchRunPivotReportsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchRunPivotReports(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::analytics::data::v1beta::BatchRunPivotReportsRequest,::google::analytics::data::v1beta::BatchRunPivotReportsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMetadata() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::analytics::data::v1beta::GetMetadataRequest, ::google::analytics::data::v1beta::Metadata>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::analytics::data::v1beta::GetMetadataRequest, ::google::analytics::data::v1beta::Metadata>* streamer) {
                       return this->StreamedGetMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMetadata(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::GetMetadataRequest* /*request*/, ::google::analytics::data::v1beta::Metadata* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::analytics::data::v1beta::GetMetadataRequest,::google::analytics::data::v1beta::Metadata>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunRealtimeReport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RunRealtimeReport() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::analytics::data::v1beta::RunRealtimeReportRequest, ::google::analytics::data::v1beta::RunRealtimeReportResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::analytics::data::v1beta::RunRealtimeReportRequest, ::google::analytics::data::v1beta::RunRealtimeReportResponse>* streamer) {
                       return this->StreamedRunRealtimeReport(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RunRealtimeReport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunRealtimeReport(::grpc::ServerContext* /*context*/, const ::google::analytics::data::v1beta::RunRealtimeReportRequest* /*request*/, ::google::analytics::data::v1beta::RunRealtimeReportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunRealtimeReport(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::analytics::data::v1beta::RunRealtimeReportRequest,::google::analytics::data::v1beta::RunRealtimeReportResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RunReport<WithStreamedUnaryMethod_RunPivotReport<WithStreamedUnaryMethod_BatchRunReports<WithStreamedUnaryMethod_BatchRunPivotReports<WithStreamedUnaryMethod_GetMetadata<WithStreamedUnaryMethod_RunRealtimeReport<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RunReport<WithStreamedUnaryMethod_RunPivotReport<WithStreamedUnaryMethod_BatchRunReports<WithStreamedUnaryMethod_BatchRunPivotReports<WithStreamedUnaryMethod_GetMetadata<WithStreamedUnaryMethod_RunRealtimeReport<Service > > > > > > StreamedService;
};

}  // namespace v1beta
}  // namespace data
}  // namespace analytics
}  // namespace google


#endif  // GRPC_google_2fanalytics_2fdata_2fv1beta_2fanalytics_5fdata_5fapi_2eproto__INCLUDED
