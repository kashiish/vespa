// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/privacy/dlp/v2/storage.proto

#ifndef PROTOBUF_INCLUDED_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto
#define PROTOBUF_INCLUDED_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/resource.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto();
namespace google {
namespace privacy {
namespace dlp {
namespace v2 {
class BigQueryField;
class BigQueryFieldDefaultTypeInternal;
extern BigQueryFieldDefaultTypeInternal _BigQueryField_default_instance_;
class BigQueryKey;
class BigQueryKeyDefaultTypeInternal;
extern BigQueryKeyDefaultTypeInternal _BigQueryKey_default_instance_;
class BigQueryOptions;
class BigQueryOptionsDefaultTypeInternal;
extern BigQueryOptionsDefaultTypeInternal _BigQueryOptions_default_instance_;
class BigQueryTable;
class BigQueryTableDefaultTypeInternal;
extern BigQueryTableDefaultTypeInternal _BigQueryTable_default_instance_;
class CloudStorageFileSet;
class CloudStorageFileSetDefaultTypeInternal;
extern CloudStorageFileSetDefaultTypeInternal _CloudStorageFileSet_default_instance_;
class CloudStorageOptions;
class CloudStorageOptionsDefaultTypeInternal;
extern CloudStorageOptionsDefaultTypeInternal _CloudStorageOptions_default_instance_;
class CloudStorageOptions_FileSet;
class CloudStorageOptions_FileSetDefaultTypeInternal;
extern CloudStorageOptions_FileSetDefaultTypeInternal _CloudStorageOptions_FileSet_default_instance_;
class CloudStoragePath;
class CloudStoragePathDefaultTypeInternal;
extern CloudStoragePathDefaultTypeInternal _CloudStoragePath_default_instance_;
class CloudStorageRegexFileSet;
class CloudStorageRegexFileSetDefaultTypeInternal;
extern CloudStorageRegexFileSetDefaultTypeInternal _CloudStorageRegexFileSet_default_instance_;
class CustomInfoType;
class CustomInfoTypeDefaultTypeInternal;
extern CustomInfoTypeDefaultTypeInternal _CustomInfoType_default_instance_;
class CustomInfoType_DetectionRule;
class CustomInfoType_DetectionRuleDefaultTypeInternal;
extern CustomInfoType_DetectionRuleDefaultTypeInternal _CustomInfoType_DetectionRule_default_instance_;
class CustomInfoType_DetectionRule_HotwordRule;
class CustomInfoType_DetectionRule_HotwordRuleDefaultTypeInternal;
extern CustomInfoType_DetectionRule_HotwordRuleDefaultTypeInternal _CustomInfoType_DetectionRule_HotwordRule_default_instance_;
class CustomInfoType_DetectionRule_LikelihoodAdjustment;
class CustomInfoType_DetectionRule_LikelihoodAdjustmentDefaultTypeInternal;
extern CustomInfoType_DetectionRule_LikelihoodAdjustmentDefaultTypeInternal _CustomInfoType_DetectionRule_LikelihoodAdjustment_default_instance_;
class CustomInfoType_DetectionRule_Proximity;
class CustomInfoType_DetectionRule_ProximityDefaultTypeInternal;
extern CustomInfoType_DetectionRule_ProximityDefaultTypeInternal _CustomInfoType_DetectionRule_Proximity_default_instance_;
class CustomInfoType_Dictionary;
class CustomInfoType_DictionaryDefaultTypeInternal;
extern CustomInfoType_DictionaryDefaultTypeInternal _CustomInfoType_Dictionary_default_instance_;
class CustomInfoType_Dictionary_WordList;
class CustomInfoType_Dictionary_WordListDefaultTypeInternal;
extern CustomInfoType_Dictionary_WordListDefaultTypeInternal _CustomInfoType_Dictionary_WordList_default_instance_;
class CustomInfoType_Regex;
class CustomInfoType_RegexDefaultTypeInternal;
extern CustomInfoType_RegexDefaultTypeInternal _CustomInfoType_Regex_default_instance_;
class CustomInfoType_SurrogateType;
class CustomInfoType_SurrogateTypeDefaultTypeInternal;
extern CustomInfoType_SurrogateTypeDefaultTypeInternal _CustomInfoType_SurrogateType_default_instance_;
class DatastoreKey;
class DatastoreKeyDefaultTypeInternal;
extern DatastoreKeyDefaultTypeInternal _DatastoreKey_default_instance_;
class DatastoreOptions;
class DatastoreOptionsDefaultTypeInternal;
extern DatastoreOptionsDefaultTypeInternal _DatastoreOptions_default_instance_;
class EntityId;
class EntityIdDefaultTypeInternal;
extern EntityIdDefaultTypeInternal _EntityId_default_instance_;
class FieldId;
class FieldIdDefaultTypeInternal;
extern FieldIdDefaultTypeInternal _FieldId_default_instance_;
class HybridOptions;
class HybridOptionsDefaultTypeInternal;
extern HybridOptionsDefaultTypeInternal _HybridOptions_default_instance_;
class HybridOptions_LabelsEntry_DoNotUse;
class HybridOptions_LabelsEntry_DoNotUseDefaultTypeInternal;
extern HybridOptions_LabelsEntry_DoNotUseDefaultTypeInternal _HybridOptions_LabelsEntry_DoNotUse_default_instance_;
class InfoType;
class InfoTypeDefaultTypeInternal;
extern InfoTypeDefaultTypeInternal _InfoType_default_instance_;
class Key;
class KeyDefaultTypeInternal;
extern KeyDefaultTypeInternal _Key_default_instance_;
class Key_PathElement;
class Key_PathElementDefaultTypeInternal;
extern Key_PathElementDefaultTypeInternal _Key_PathElement_default_instance_;
class KindExpression;
class KindExpressionDefaultTypeInternal;
extern KindExpressionDefaultTypeInternal _KindExpression_default_instance_;
class PartitionId;
class PartitionIdDefaultTypeInternal;
extern PartitionIdDefaultTypeInternal _PartitionId_default_instance_;
class RecordKey;
class RecordKeyDefaultTypeInternal;
extern RecordKeyDefaultTypeInternal _RecordKey_default_instance_;
class StorageConfig;
class StorageConfigDefaultTypeInternal;
extern StorageConfigDefaultTypeInternal _StorageConfig_default_instance_;
class StorageConfig_TimespanConfig;
class StorageConfig_TimespanConfigDefaultTypeInternal;
extern StorageConfig_TimespanConfigDefaultTypeInternal _StorageConfig_TimespanConfig_default_instance_;
class StoredType;
class StoredTypeDefaultTypeInternal;
extern StoredTypeDefaultTypeInternal _StoredType_default_instance_;
class TableOptions;
class TableOptionsDefaultTypeInternal;
extern TableOptionsDefaultTypeInternal _TableOptions_default_instance_;
}  // namespace v2
}  // namespace dlp
}  // namespace privacy
namespace protobuf {
template<> ::google::privacy::dlp::v2::BigQueryField* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryField>(Arena*);
template<> ::google::privacy::dlp::v2::BigQueryKey* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryKey>(Arena*);
template<> ::google::privacy::dlp::v2::BigQueryOptions* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryOptions>(Arena*);
template<> ::google::privacy::dlp::v2::BigQueryTable* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryTable>(Arena*);
template<> ::google::privacy::dlp::v2::CloudStorageFileSet* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CloudStorageFileSet>(Arena*);
template<> ::google::privacy::dlp::v2::CloudStorageOptions* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CloudStorageOptions>(Arena*);
template<> ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CloudStorageOptions_FileSet>(Arena*);
template<> ::google::privacy::dlp::v2::CloudStoragePath* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CloudStoragePath>(Arena*);
template<> ::google::privacy::dlp::v2::CloudStorageRegexFileSet* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CloudStorageRegexFileSet>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_DetectionRule* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_DetectionRule>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_Dictionary* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_Dictionary>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_Regex* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_Regex>(Arena*);
template<> ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_SurrogateType>(Arena*);
template<> ::google::privacy::dlp::v2::DatastoreKey* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::DatastoreKey>(Arena*);
template<> ::google::privacy::dlp::v2::DatastoreOptions* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::DatastoreOptions>(Arena*);
template<> ::google::privacy::dlp::v2::EntityId* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::EntityId>(Arena*);
template<> ::google::privacy::dlp::v2::FieldId* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::FieldId>(Arena*);
template<> ::google::privacy::dlp::v2::HybridOptions* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::HybridOptions>(Arena*);
template<> ::google::privacy::dlp::v2::HybridOptions_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::HybridOptions_LabelsEntry_DoNotUse>(Arena*);
template<> ::google::privacy::dlp::v2::InfoType* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::InfoType>(Arena*);
template<> ::google::privacy::dlp::v2::Key* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::Key>(Arena*);
template<> ::google::privacy::dlp::v2::Key_PathElement* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::Key_PathElement>(Arena*);
template<> ::google::privacy::dlp::v2::KindExpression* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::KindExpression>(Arena*);
template<> ::google::privacy::dlp::v2::PartitionId* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::PartitionId>(Arena*);
template<> ::google::privacy::dlp::v2::RecordKey* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::RecordKey>(Arena*);
template<> ::google::privacy::dlp::v2::StorageConfig* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::StorageConfig>(Arena*);
template<> ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::StorageConfig_TimespanConfig>(Arena*);
template<> ::google::privacy::dlp::v2::StoredType* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::StoredType>(Arena*);
template<> ::google::privacy::dlp::v2::TableOptions* Arena::CreateMaybeMessage<::google::privacy::dlp::v2::TableOptions>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace google {
namespace privacy {
namespace dlp {
namespace v2 {

enum CustomInfoType_ExclusionType {
  CustomInfoType_ExclusionType_EXCLUSION_TYPE_UNSPECIFIED = 0,
  CustomInfoType_ExclusionType_EXCLUSION_TYPE_EXCLUDE = 1,
  CustomInfoType_ExclusionType_CustomInfoType_ExclusionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  CustomInfoType_ExclusionType_CustomInfoType_ExclusionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool CustomInfoType_ExclusionType_IsValid(int value);
const CustomInfoType_ExclusionType CustomInfoType_ExclusionType_ExclusionType_MIN = CustomInfoType_ExclusionType_EXCLUSION_TYPE_UNSPECIFIED;
const CustomInfoType_ExclusionType CustomInfoType_ExclusionType_ExclusionType_MAX = CustomInfoType_ExclusionType_EXCLUSION_TYPE_EXCLUDE;
const int CustomInfoType_ExclusionType_ExclusionType_ARRAYSIZE = CustomInfoType_ExclusionType_ExclusionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CustomInfoType_ExclusionType_descriptor();
inline const ::std::string& CustomInfoType_ExclusionType_Name(CustomInfoType_ExclusionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CustomInfoType_ExclusionType_descriptor(), value);
}
inline bool CustomInfoType_ExclusionType_Parse(
    const ::std::string& name, CustomInfoType_ExclusionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomInfoType_ExclusionType>(
    CustomInfoType_ExclusionType_descriptor(), name, value);
}
enum CloudStorageOptions_SampleMethod {
  CloudStorageOptions_SampleMethod_SAMPLE_METHOD_UNSPECIFIED = 0,
  CloudStorageOptions_SampleMethod_TOP = 1,
  CloudStorageOptions_SampleMethod_RANDOM_START = 2,
  CloudStorageOptions_SampleMethod_CloudStorageOptions_SampleMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  CloudStorageOptions_SampleMethod_CloudStorageOptions_SampleMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool CloudStorageOptions_SampleMethod_IsValid(int value);
const CloudStorageOptions_SampleMethod CloudStorageOptions_SampleMethod_SampleMethod_MIN = CloudStorageOptions_SampleMethod_SAMPLE_METHOD_UNSPECIFIED;
const CloudStorageOptions_SampleMethod CloudStorageOptions_SampleMethod_SampleMethod_MAX = CloudStorageOptions_SampleMethod_RANDOM_START;
const int CloudStorageOptions_SampleMethod_SampleMethod_ARRAYSIZE = CloudStorageOptions_SampleMethod_SampleMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* CloudStorageOptions_SampleMethod_descriptor();
inline const ::std::string& CloudStorageOptions_SampleMethod_Name(CloudStorageOptions_SampleMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    CloudStorageOptions_SampleMethod_descriptor(), value);
}
inline bool CloudStorageOptions_SampleMethod_Parse(
    const ::std::string& name, CloudStorageOptions_SampleMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CloudStorageOptions_SampleMethod>(
    CloudStorageOptions_SampleMethod_descriptor(), name, value);
}
enum BigQueryOptions_SampleMethod {
  BigQueryOptions_SampleMethod_SAMPLE_METHOD_UNSPECIFIED = 0,
  BigQueryOptions_SampleMethod_TOP = 1,
  BigQueryOptions_SampleMethod_RANDOM_START = 2,
  BigQueryOptions_SampleMethod_BigQueryOptions_SampleMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  BigQueryOptions_SampleMethod_BigQueryOptions_SampleMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool BigQueryOptions_SampleMethod_IsValid(int value);
const BigQueryOptions_SampleMethod BigQueryOptions_SampleMethod_SampleMethod_MIN = BigQueryOptions_SampleMethod_SAMPLE_METHOD_UNSPECIFIED;
const BigQueryOptions_SampleMethod BigQueryOptions_SampleMethod_SampleMethod_MAX = BigQueryOptions_SampleMethod_RANDOM_START;
const int BigQueryOptions_SampleMethod_SampleMethod_ARRAYSIZE = BigQueryOptions_SampleMethod_SampleMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* BigQueryOptions_SampleMethod_descriptor();
inline const ::std::string& BigQueryOptions_SampleMethod_Name(BigQueryOptions_SampleMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    BigQueryOptions_SampleMethod_descriptor(), value);
}
inline bool BigQueryOptions_SampleMethod_Parse(
    const ::std::string& name, BigQueryOptions_SampleMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BigQueryOptions_SampleMethod>(
    BigQueryOptions_SampleMethod_descriptor(), name, value);
}
enum Likelihood {
  LIKELIHOOD_UNSPECIFIED = 0,
  VERY_UNLIKELY = 1,
  UNLIKELY = 2,
  POSSIBLE = 3,
  LIKELY = 4,
  VERY_LIKELY = 5,
  Likelihood_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Likelihood_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Likelihood_IsValid(int value);
const Likelihood Likelihood_MIN = LIKELIHOOD_UNSPECIFIED;
const Likelihood Likelihood_MAX = VERY_LIKELY;
const int Likelihood_ARRAYSIZE = Likelihood_MAX + 1;

const ::google::protobuf::EnumDescriptor* Likelihood_descriptor();
inline const ::std::string& Likelihood_Name(Likelihood value) {
  return ::google::protobuf::internal::NameOfEnum(
    Likelihood_descriptor(), value);
}
inline bool Likelihood_Parse(
    const ::std::string& name, Likelihood* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Likelihood>(
    Likelihood_descriptor(), name, value);
}
enum FileType {
  FILE_TYPE_UNSPECIFIED = 0,
  BINARY_FILE = 1,
  TEXT_FILE = 2,
  IMAGE = 3,
  WORD = 5,
  PDF = 6,
  AVRO = 7,
  CSV = 8,
  TSV = 9,
  FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = FILE_TYPE_UNSPECIFIED;
const FileType FileType_MAX = TSV;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileType_descriptor();
inline const ::std::string& FileType_Name(FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileType_descriptor(), value);
}
inline bool FileType_Parse(
    const ::std::string& name, FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
// ===================================================================

class InfoType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.InfoType) */ {
 public:
  InfoType();
  virtual ~InfoType();

  InfoType(const InfoType& from);

  inline InfoType& operator=(const InfoType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InfoType(InfoType&& from) noexcept
    : InfoType() {
    *this = ::std::move(from);
  }

  inline InfoType& operator=(InfoType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InfoType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfoType* internal_default_instance() {
    return reinterpret_cast<const InfoType*>(
               &_InfoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InfoType* other);
  friend void swap(InfoType& a, InfoType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InfoType* New() const final {
    return CreateMaybeMessage<InfoType>(nullptr);
  }

  InfoType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InfoType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InfoType& from);
  void MergeFrom(const InfoType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.InfoType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class StoredType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.StoredType) */ {
 public:
  StoredType();
  virtual ~StoredType();

  StoredType(const StoredType& from);

  inline StoredType& operator=(const StoredType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StoredType(StoredType&& from) noexcept
    : StoredType() {
    *this = ::std::move(from);
  }

  inline StoredType& operator=(StoredType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StoredType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoredType* internal_default_instance() {
    return reinterpret_cast<const StoredType*>(
               &_StoredType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(StoredType* other);
  friend void swap(StoredType& a, StoredType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoredType* New() const final {
    return CreateMaybeMessage<StoredType>(nullptr);
  }

  StoredType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StoredType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StoredType& from);
  void MergeFrom(const StoredType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoredType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.Timestamp create_time = 2;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 2;
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.StoredType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::Timestamp* create_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_Dictionary_WordList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList) */ {
 public:
  CustomInfoType_Dictionary_WordList();
  virtual ~CustomInfoType_Dictionary_WordList();

  CustomInfoType_Dictionary_WordList(const CustomInfoType_Dictionary_WordList& from);

  inline CustomInfoType_Dictionary_WordList& operator=(const CustomInfoType_Dictionary_WordList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_Dictionary_WordList(CustomInfoType_Dictionary_WordList&& from) noexcept
    : CustomInfoType_Dictionary_WordList() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_Dictionary_WordList& operator=(CustomInfoType_Dictionary_WordList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_Dictionary_WordList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_Dictionary_WordList* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_Dictionary_WordList*>(
               &_CustomInfoType_Dictionary_WordList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CustomInfoType_Dictionary_WordList* other);
  friend void swap(CustomInfoType_Dictionary_WordList& a, CustomInfoType_Dictionary_WordList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_Dictionary_WordList* New() const final {
    return CreateMaybeMessage<CustomInfoType_Dictionary_WordList>(nullptr);
  }

  CustomInfoType_Dictionary_WordList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_Dictionary_WordList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_Dictionary_WordList& from);
  void MergeFrom(const CustomInfoType_Dictionary_WordList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_Dictionary_WordList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string words = 1;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  const ::std::string& words(int index) const;
  ::std::string* mutable_words(int index);
  void set_words(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_words(int index, ::std::string&& value);
  #endif
  void set_words(int index, const char* value);
  void set_words(int index, const char* value, size_t size);
  ::std::string* add_words();
  void add_words(const ::std::string& value);
  #if LANG_CXX11
  void add_words(::std::string&& value);
  #endif
  void add_words(const char* value);
  void add_words(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& words() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_words();

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> words_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_Dictionary final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.Dictionary) */ {
 public:
  CustomInfoType_Dictionary();
  virtual ~CustomInfoType_Dictionary();

  CustomInfoType_Dictionary(const CustomInfoType_Dictionary& from);

  inline CustomInfoType_Dictionary& operator=(const CustomInfoType_Dictionary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_Dictionary(CustomInfoType_Dictionary&& from) noexcept
    : CustomInfoType_Dictionary() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_Dictionary& operator=(CustomInfoType_Dictionary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_Dictionary& default_instance();

  enum SourceCase {
    kWordList = 1,
    kCloudStoragePath = 3,
    SOURCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_Dictionary* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_Dictionary*>(
               &_CustomInfoType_Dictionary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CustomInfoType_Dictionary* other);
  friend void swap(CustomInfoType_Dictionary& a, CustomInfoType_Dictionary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_Dictionary* New() const final {
    return CreateMaybeMessage<CustomInfoType_Dictionary>(nullptr);
  }

  CustomInfoType_Dictionary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_Dictionary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_Dictionary& from);
  void MergeFrom(const CustomInfoType_Dictionary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_Dictionary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CustomInfoType_Dictionary_WordList WordList;

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList word_list = 1;
  bool has_word_list() const;
  void clear_word_list();
  static const int kWordListFieldNumber = 1;
  const ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList& word_list() const;
  ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* release_word_list();
  ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* mutable_word_list();
  void set_allocated_word_list(::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* word_list);

  // .google.privacy.dlp.v2.CloudStoragePath cloud_storage_path = 3;
  bool has_cloud_storage_path() const;
  void clear_cloud_storage_path();
  static const int kCloudStoragePathFieldNumber = 3;
  const ::google::privacy::dlp::v2::CloudStoragePath& cloud_storage_path() const;
  ::google::privacy::dlp::v2::CloudStoragePath* release_cloud_storage_path();
  ::google::privacy::dlp::v2::CloudStoragePath* mutable_cloud_storage_path();
  void set_allocated_cloud_storage_path(::google::privacy::dlp::v2::CloudStoragePath* cloud_storage_path);

  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.Dictionary)
 private:
  class HasBitSetters;
  void set_has_word_list();
  void set_has_cloud_storage_path();

  inline bool has_source() const;
  inline void clear_has_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SourceUnion {
    SourceUnion() {}
    ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* word_list_;
    ::google::privacy::dlp::v2::CloudStoragePath* cloud_storage_path_;
  } source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_Regex final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.Regex) */ {
 public:
  CustomInfoType_Regex();
  virtual ~CustomInfoType_Regex();

  CustomInfoType_Regex(const CustomInfoType_Regex& from);

  inline CustomInfoType_Regex& operator=(const CustomInfoType_Regex& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_Regex(CustomInfoType_Regex&& from) noexcept
    : CustomInfoType_Regex() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_Regex& operator=(CustomInfoType_Regex&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_Regex& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_Regex* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_Regex*>(
               &_CustomInfoType_Regex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CustomInfoType_Regex* other);
  friend void swap(CustomInfoType_Regex& a, CustomInfoType_Regex& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_Regex* New() const final {
    return CreateMaybeMessage<CustomInfoType_Regex>(nullptr);
  }

  CustomInfoType_Regex* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_Regex>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_Regex& from);
  void MergeFrom(const CustomInfoType_Regex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_Regex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 group_indexes = 2;
  int group_indexes_size() const;
  void clear_group_indexes();
  static const int kGroupIndexesFieldNumber = 2;
  ::google::protobuf::int32 group_indexes(int index) const;
  void set_group_indexes(int index, ::google::protobuf::int32 value);
  void add_group_indexes(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      group_indexes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_group_indexes();

  // string pattern = 1;
  void clear_pattern();
  static const int kPatternFieldNumber = 1;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.Regex)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > group_indexes_;
  mutable std::atomic<int> _group_indexes_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_SurrogateType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.SurrogateType) */ {
 public:
  CustomInfoType_SurrogateType();
  virtual ~CustomInfoType_SurrogateType();

  CustomInfoType_SurrogateType(const CustomInfoType_SurrogateType& from);

  inline CustomInfoType_SurrogateType& operator=(const CustomInfoType_SurrogateType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_SurrogateType(CustomInfoType_SurrogateType&& from) noexcept
    : CustomInfoType_SurrogateType() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_SurrogateType& operator=(CustomInfoType_SurrogateType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_SurrogateType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_SurrogateType* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_SurrogateType*>(
               &_CustomInfoType_SurrogateType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CustomInfoType_SurrogateType* other);
  friend void swap(CustomInfoType_SurrogateType& a, CustomInfoType_SurrogateType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_SurrogateType* New() const final {
    return CreateMaybeMessage<CustomInfoType_SurrogateType>(nullptr);
  }

  CustomInfoType_SurrogateType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_SurrogateType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_SurrogateType& from);
  void MergeFrom(const CustomInfoType_SurrogateType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_SurrogateType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.SurrogateType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_DetectionRule_Proximity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity) */ {
 public:
  CustomInfoType_DetectionRule_Proximity();
  virtual ~CustomInfoType_DetectionRule_Proximity();

  CustomInfoType_DetectionRule_Proximity(const CustomInfoType_DetectionRule_Proximity& from);

  inline CustomInfoType_DetectionRule_Proximity& operator=(const CustomInfoType_DetectionRule_Proximity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_DetectionRule_Proximity(CustomInfoType_DetectionRule_Proximity&& from) noexcept
    : CustomInfoType_DetectionRule_Proximity() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_DetectionRule_Proximity& operator=(CustomInfoType_DetectionRule_Proximity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_DetectionRule_Proximity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_DetectionRule_Proximity* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_DetectionRule_Proximity*>(
               &_CustomInfoType_DetectionRule_Proximity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CustomInfoType_DetectionRule_Proximity* other);
  friend void swap(CustomInfoType_DetectionRule_Proximity& a, CustomInfoType_DetectionRule_Proximity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_DetectionRule_Proximity* New() const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule_Proximity>(nullptr);
  }

  CustomInfoType_DetectionRule_Proximity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule_Proximity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_DetectionRule_Proximity& from);
  void MergeFrom(const CustomInfoType_DetectionRule_Proximity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_DetectionRule_Proximity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 window_before = 1;
  void clear_window_before();
  static const int kWindowBeforeFieldNumber = 1;
  ::google::protobuf::int32 window_before() const;
  void set_window_before(::google::protobuf::int32 value);

  // int32 window_after = 2;
  void clear_window_after();
  static const int kWindowAfterFieldNumber = 2;
  ::google::protobuf::int32 window_after() const;
  void set_window_after(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 window_before_;
  ::google::protobuf::int32 window_after_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_DetectionRule_LikelihoodAdjustment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment) */ {
 public:
  CustomInfoType_DetectionRule_LikelihoodAdjustment();
  virtual ~CustomInfoType_DetectionRule_LikelihoodAdjustment();

  CustomInfoType_DetectionRule_LikelihoodAdjustment(const CustomInfoType_DetectionRule_LikelihoodAdjustment& from);

  inline CustomInfoType_DetectionRule_LikelihoodAdjustment& operator=(const CustomInfoType_DetectionRule_LikelihoodAdjustment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_DetectionRule_LikelihoodAdjustment(CustomInfoType_DetectionRule_LikelihoodAdjustment&& from) noexcept
    : CustomInfoType_DetectionRule_LikelihoodAdjustment() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_DetectionRule_LikelihoodAdjustment& operator=(CustomInfoType_DetectionRule_LikelihoodAdjustment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_DetectionRule_LikelihoodAdjustment& default_instance();

  enum AdjustmentCase {
    kFixedLikelihood = 1,
    kRelativeLikelihood = 2,
    ADJUSTMENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_DetectionRule_LikelihoodAdjustment* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_DetectionRule_LikelihoodAdjustment*>(
               &_CustomInfoType_DetectionRule_LikelihoodAdjustment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CustomInfoType_DetectionRule_LikelihoodAdjustment* other);
  friend void swap(CustomInfoType_DetectionRule_LikelihoodAdjustment& a, CustomInfoType_DetectionRule_LikelihoodAdjustment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_DetectionRule_LikelihoodAdjustment* New() const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule_LikelihoodAdjustment>(nullptr);
  }

  CustomInfoType_DetectionRule_LikelihoodAdjustment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule_LikelihoodAdjustment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_DetectionRule_LikelihoodAdjustment& from);
  void MergeFrom(const CustomInfoType_DetectionRule_LikelihoodAdjustment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_DetectionRule_LikelihoodAdjustment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.Likelihood fixed_likelihood = 1;
  private:
  bool has_fixed_likelihood() const;
  public:
  void clear_fixed_likelihood();
  static const int kFixedLikelihoodFieldNumber = 1;
  ::google::privacy::dlp::v2::Likelihood fixed_likelihood() const;
  void set_fixed_likelihood(::google::privacy::dlp::v2::Likelihood value);

  // int32 relative_likelihood = 2;
  private:
  bool has_relative_likelihood() const;
  public:
  void clear_relative_likelihood();
  static const int kRelativeLikelihoodFieldNumber = 2;
  ::google::protobuf::int32 relative_likelihood() const;
  void set_relative_likelihood(::google::protobuf::int32 value);

  void clear_adjustment();
  AdjustmentCase adjustment_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment)
 private:
  class HasBitSetters;
  void set_has_fixed_likelihood();
  void set_has_relative_likelihood();

  inline bool has_adjustment() const;
  inline void clear_has_adjustment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union AdjustmentUnion {
    AdjustmentUnion() {}
    int fixed_likelihood_;
    ::google::protobuf::int32 relative_likelihood_;
  } adjustment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_DetectionRule_HotwordRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule) */ {
 public:
  CustomInfoType_DetectionRule_HotwordRule();
  virtual ~CustomInfoType_DetectionRule_HotwordRule();

  CustomInfoType_DetectionRule_HotwordRule(const CustomInfoType_DetectionRule_HotwordRule& from);

  inline CustomInfoType_DetectionRule_HotwordRule& operator=(const CustomInfoType_DetectionRule_HotwordRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_DetectionRule_HotwordRule(CustomInfoType_DetectionRule_HotwordRule&& from) noexcept
    : CustomInfoType_DetectionRule_HotwordRule() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_DetectionRule_HotwordRule& operator=(CustomInfoType_DetectionRule_HotwordRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_DetectionRule_HotwordRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_DetectionRule_HotwordRule* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_DetectionRule_HotwordRule*>(
               &_CustomInfoType_DetectionRule_HotwordRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CustomInfoType_DetectionRule_HotwordRule* other);
  friend void swap(CustomInfoType_DetectionRule_HotwordRule& a, CustomInfoType_DetectionRule_HotwordRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_DetectionRule_HotwordRule* New() const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule_HotwordRule>(nullptr);
  }

  CustomInfoType_DetectionRule_HotwordRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule_HotwordRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_DetectionRule_HotwordRule& from);
  void MergeFrom(const CustomInfoType_DetectionRule_HotwordRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_DetectionRule_HotwordRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.CustomInfoType.Regex hotword_regex = 1;
  bool has_hotword_regex() const;
  void clear_hotword_regex();
  static const int kHotwordRegexFieldNumber = 1;
  const ::google::privacy::dlp::v2::CustomInfoType_Regex& hotword_regex() const;
  ::google::privacy::dlp::v2::CustomInfoType_Regex* release_hotword_regex();
  ::google::privacy::dlp::v2::CustomInfoType_Regex* mutable_hotword_regex();
  void set_allocated_hotword_regex(::google::privacy::dlp::v2::CustomInfoType_Regex* hotword_regex);

  // .google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity proximity = 2;
  bool has_proximity() const;
  void clear_proximity();
  static const int kProximityFieldNumber = 2;
  const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity& proximity() const;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* release_proximity();
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* mutable_proximity();
  void set_allocated_proximity(::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* proximity);

  // .google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment likelihood_adjustment = 3;
  bool has_likelihood_adjustment() const;
  void clear_likelihood_adjustment();
  static const int kLikelihoodAdjustmentFieldNumber = 3;
  const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment& likelihood_adjustment() const;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* release_likelihood_adjustment();
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* mutable_likelihood_adjustment();
  void set_allocated_likelihood_adjustment(::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* likelihood_adjustment);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::CustomInfoType_Regex* hotword_regex_;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* proximity_;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* likelihood_adjustment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType_DetectionRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType.DetectionRule) */ {
 public:
  CustomInfoType_DetectionRule();
  virtual ~CustomInfoType_DetectionRule();

  CustomInfoType_DetectionRule(const CustomInfoType_DetectionRule& from);

  inline CustomInfoType_DetectionRule& operator=(const CustomInfoType_DetectionRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType_DetectionRule(CustomInfoType_DetectionRule&& from) noexcept
    : CustomInfoType_DetectionRule() {
    *this = ::std::move(from);
  }

  inline CustomInfoType_DetectionRule& operator=(CustomInfoType_DetectionRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType_DetectionRule& default_instance();

  enum TypeCase {
    kHotwordRule = 1,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType_DetectionRule* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType_DetectionRule*>(
               &_CustomInfoType_DetectionRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CustomInfoType_DetectionRule* other);
  friend void swap(CustomInfoType_DetectionRule& a, CustomInfoType_DetectionRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType_DetectionRule* New() const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule>(nullptr);
  }

  CustomInfoType_DetectionRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType_DetectionRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType_DetectionRule& from);
  void MergeFrom(const CustomInfoType_DetectionRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType_DetectionRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CustomInfoType_DetectionRule_Proximity Proximity;
  typedef CustomInfoType_DetectionRule_LikelihoodAdjustment LikelihoodAdjustment;
  typedef CustomInfoType_DetectionRule_HotwordRule HotwordRule;

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule hotword_rule = 1;
  bool has_hotword_rule() const;
  void clear_hotword_rule();
  static const int kHotwordRuleFieldNumber = 1;
  const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule& hotword_rule() const;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* release_hotword_rule();
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* mutable_hotword_rule();
  void set_allocated_hotword_rule(::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* hotword_rule);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType.DetectionRule)
 private:
  class HasBitSetters;
  void set_has_hotword_rule();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* hotword_rule_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CustomInfoType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CustomInfoType) */ {
 public:
  CustomInfoType();
  virtual ~CustomInfoType();

  CustomInfoType(const CustomInfoType& from);

  inline CustomInfoType& operator=(const CustomInfoType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomInfoType(CustomInfoType&& from) noexcept
    : CustomInfoType() {
    *this = ::std::move(from);
  }

  inline CustomInfoType& operator=(CustomInfoType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomInfoType& default_instance();

  enum TypeCase {
    kDictionary = 2,
    kRegex = 3,
    kSurrogateType = 4,
    kStoredType = 5,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomInfoType* internal_default_instance() {
    return reinterpret_cast<const CustomInfoType*>(
               &_CustomInfoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CustomInfoType* other);
  friend void swap(CustomInfoType& a, CustomInfoType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomInfoType* New() const final {
    return CreateMaybeMessage<CustomInfoType>(nullptr);
  }

  CustomInfoType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomInfoType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomInfoType& from);
  void MergeFrom(const CustomInfoType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomInfoType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CustomInfoType_Dictionary Dictionary;
  typedef CustomInfoType_Regex Regex;
  typedef CustomInfoType_SurrogateType SurrogateType;
  typedef CustomInfoType_DetectionRule DetectionRule;

  typedef CustomInfoType_ExclusionType ExclusionType;
  static const ExclusionType EXCLUSION_TYPE_UNSPECIFIED =
    CustomInfoType_ExclusionType_EXCLUSION_TYPE_UNSPECIFIED;
  static const ExclusionType EXCLUSION_TYPE_EXCLUDE =
    CustomInfoType_ExclusionType_EXCLUSION_TYPE_EXCLUDE;
  static inline bool ExclusionType_IsValid(int value) {
    return CustomInfoType_ExclusionType_IsValid(value);
  }
  static const ExclusionType ExclusionType_MIN =
    CustomInfoType_ExclusionType_ExclusionType_MIN;
  static const ExclusionType ExclusionType_MAX =
    CustomInfoType_ExclusionType_ExclusionType_MAX;
  static const int ExclusionType_ARRAYSIZE =
    CustomInfoType_ExclusionType_ExclusionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExclusionType_descriptor() {
    return CustomInfoType_ExclusionType_descriptor();
  }
  static inline const ::std::string& ExclusionType_Name(ExclusionType value) {
    return CustomInfoType_ExclusionType_Name(value);
  }
  static inline bool ExclusionType_Parse(const ::std::string& name,
      ExclusionType* value) {
    return CustomInfoType_ExclusionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .google.privacy.dlp.v2.CustomInfoType.DetectionRule detection_rules = 7;
  int detection_rules_size() const;
  void clear_detection_rules();
  static const int kDetectionRulesFieldNumber = 7;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule* mutable_detection_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule >*
      mutable_detection_rules();
  const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule& detection_rules(int index) const;
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule* add_detection_rules();
  const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule >&
      detection_rules() const;

  // .google.privacy.dlp.v2.InfoType info_type = 1;
  bool has_info_type() const;
  void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  const ::google::privacy::dlp::v2::InfoType& info_type() const;
  ::google::privacy::dlp::v2::InfoType* release_info_type();
  ::google::privacy::dlp::v2::InfoType* mutable_info_type();
  void set_allocated_info_type(::google::privacy::dlp::v2::InfoType* info_type);

  // .google.privacy.dlp.v2.Likelihood likelihood = 6;
  void clear_likelihood();
  static const int kLikelihoodFieldNumber = 6;
  ::google::privacy::dlp::v2::Likelihood likelihood() const;
  void set_likelihood(::google::privacy::dlp::v2::Likelihood value);

  // .google.privacy.dlp.v2.CustomInfoType.ExclusionType exclusion_type = 8;
  void clear_exclusion_type();
  static const int kExclusionTypeFieldNumber = 8;
  ::google::privacy::dlp::v2::CustomInfoType_ExclusionType exclusion_type() const;
  void set_exclusion_type(::google::privacy::dlp::v2::CustomInfoType_ExclusionType value);

  // .google.privacy.dlp.v2.CustomInfoType.Dictionary dictionary = 2;
  bool has_dictionary() const;
  void clear_dictionary();
  static const int kDictionaryFieldNumber = 2;
  const ::google::privacy::dlp::v2::CustomInfoType_Dictionary& dictionary() const;
  ::google::privacy::dlp::v2::CustomInfoType_Dictionary* release_dictionary();
  ::google::privacy::dlp::v2::CustomInfoType_Dictionary* mutable_dictionary();
  void set_allocated_dictionary(::google::privacy::dlp::v2::CustomInfoType_Dictionary* dictionary);

  // .google.privacy.dlp.v2.CustomInfoType.Regex regex = 3;
  bool has_regex() const;
  void clear_regex();
  static const int kRegexFieldNumber = 3;
  const ::google::privacy::dlp::v2::CustomInfoType_Regex& regex() const;
  ::google::privacy::dlp::v2::CustomInfoType_Regex* release_regex();
  ::google::privacy::dlp::v2::CustomInfoType_Regex* mutable_regex();
  void set_allocated_regex(::google::privacy::dlp::v2::CustomInfoType_Regex* regex);

  // .google.privacy.dlp.v2.CustomInfoType.SurrogateType surrogate_type = 4;
  bool has_surrogate_type() const;
  void clear_surrogate_type();
  static const int kSurrogateTypeFieldNumber = 4;
  const ::google::privacy::dlp::v2::CustomInfoType_SurrogateType& surrogate_type() const;
  ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* release_surrogate_type();
  ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* mutable_surrogate_type();
  void set_allocated_surrogate_type(::google::privacy::dlp::v2::CustomInfoType_SurrogateType* surrogate_type);

  // .google.privacy.dlp.v2.StoredType stored_type = 5;
  bool has_stored_type() const;
  void clear_stored_type();
  static const int kStoredTypeFieldNumber = 5;
  const ::google::privacy::dlp::v2::StoredType& stored_type() const;
  ::google::privacy::dlp::v2::StoredType* release_stored_type();
  ::google::privacy::dlp::v2::StoredType* mutable_stored_type();
  void set_allocated_stored_type(::google::privacy::dlp::v2::StoredType* stored_type);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CustomInfoType)
 private:
  class HasBitSetters;
  void set_has_dictionary();
  void set_has_regex();
  void set_has_surrogate_type();
  void set_has_stored_type();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule > detection_rules_;
  ::google::privacy::dlp::v2::InfoType* info_type_;
  int likelihood_;
  int exclusion_type_;
  union TypeUnion {
    TypeUnion() {}
    ::google::privacy::dlp::v2::CustomInfoType_Dictionary* dictionary_;
    ::google::privacy::dlp::v2::CustomInfoType_Regex* regex_;
    ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* surrogate_type_;
    ::google::privacy::dlp::v2::StoredType* stored_type_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class FieldId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.FieldId) */ {
 public:
  FieldId();
  virtual ~FieldId();

  FieldId(const FieldId& from);

  inline FieldId& operator=(const FieldId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldId(FieldId&& from) noexcept
    : FieldId() {
    *this = ::std::move(from);
  }

  inline FieldId& operator=(FieldId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FieldId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FieldId* internal_default_instance() {
    return reinterpret_cast<const FieldId*>(
               &_FieldId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FieldId* other);
  friend void swap(FieldId& a, FieldId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldId* New() const final {
    return CreateMaybeMessage<FieldId>(nullptr);
  }

  FieldId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FieldId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FieldId& from);
  void MergeFrom(const FieldId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.FieldId)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class PartitionId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.PartitionId) */ {
 public:
  PartitionId();
  virtual ~PartitionId();

  PartitionId(const PartitionId& from);

  inline PartitionId& operator=(const PartitionId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionId(PartitionId&& from) noexcept
    : PartitionId() {
    *this = ::std::move(from);
  }

  inline PartitionId& operator=(PartitionId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PartitionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionId* internal_default_instance() {
    return reinterpret_cast<const PartitionId*>(
               &_PartitionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PartitionId* other);
  friend void swap(PartitionId& a, PartitionId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionId* New() const final {
    return CreateMaybeMessage<PartitionId>(nullptr);
  }

  PartitionId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionId& from);
  void MergeFrom(const PartitionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project_id = 2;
  void clear_project_id();
  static const int kProjectIdFieldNumber = 2;
  const ::std::string& project_id() const;
  void set_project_id(const ::std::string& value);
  #if LANG_CXX11
  void set_project_id(::std::string&& value);
  #endif
  void set_project_id(const char* value);
  void set_project_id(const char* value, size_t size);
  ::std::string* mutable_project_id();
  ::std::string* release_project_id();
  void set_allocated_project_id(::std::string* project_id);

  // string namespace_id = 4;
  void clear_namespace_id();
  static const int kNamespaceIdFieldNumber = 4;
  const ::std::string& namespace_id() const;
  void set_namespace_id(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_id(::std::string&& value);
  #endif
  void set_namespace_id(const char* value);
  void set_namespace_id(const char* value, size_t size);
  ::std::string* mutable_namespace_id();
  ::std::string* release_namespace_id();
  void set_allocated_namespace_id(::std::string* namespace_id);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.PartitionId)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_id_;
  ::google::protobuf::internal::ArenaStringPtr namespace_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class KindExpression final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.KindExpression) */ {
 public:
  KindExpression();
  virtual ~KindExpression();

  KindExpression(const KindExpression& from);

  inline KindExpression& operator=(const KindExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KindExpression(KindExpression&& from) noexcept
    : KindExpression() {
    *this = ::std::move(from);
  }

  inline KindExpression& operator=(KindExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const KindExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KindExpression* internal_default_instance() {
    return reinterpret_cast<const KindExpression*>(
               &_KindExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(KindExpression* other);
  friend void swap(KindExpression& a, KindExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KindExpression* New() const final {
    return CreateMaybeMessage<KindExpression>(nullptr);
  }

  KindExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KindExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KindExpression& from);
  void MergeFrom(const KindExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KindExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.KindExpression)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class DatastoreOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.DatastoreOptions) */ {
 public:
  DatastoreOptions();
  virtual ~DatastoreOptions();

  DatastoreOptions(const DatastoreOptions& from);

  inline DatastoreOptions& operator=(const DatastoreOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatastoreOptions(DatastoreOptions&& from) noexcept
    : DatastoreOptions() {
    *this = ::std::move(from);
  }

  inline DatastoreOptions& operator=(DatastoreOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DatastoreOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatastoreOptions* internal_default_instance() {
    return reinterpret_cast<const DatastoreOptions*>(
               &_DatastoreOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DatastoreOptions* other);
  friend void swap(DatastoreOptions& a, DatastoreOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatastoreOptions* New() const final {
    return CreateMaybeMessage<DatastoreOptions>(nullptr);
  }

  DatastoreOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatastoreOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatastoreOptions& from);
  void MergeFrom(const DatastoreOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatastoreOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.PartitionId partition_id = 1;
  bool has_partition_id() const;
  void clear_partition_id();
  static const int kPartitionIdFieldNumber = 1;
  const ::google::privacy::dlp::v2::PartitionId& partition_id() const;
  ::google::privacy::dlp::v2::PartitionId* release_partition_id();
  ::google::privacy::dlp::v2::PartitionId* mutable_partition_id();
  void set_allocated_partition_id(::google::privacy::dlp::v2::PartitionId* partition_id);

  // .google.privacy.dlp.v2.KindExpression kind = 2;
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 2;
  const ::google::privacy::dlp::v2::KindExpression& kind() const;
  ::google::privacy::dlp::v2::KindExpression* release_kind();
  ::google::privacy::dlp::v2::KindExpression* mutable_kind();
  void set_allocated_kind(::google::privacy::dlp::v2::KindExpression* kind);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.DatastoreOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::PartitionId* partition_id_;
  ::google::privacy::dlp::v2::KindExpression* kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CloudStorageRegexFileSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CloudStorageRegexFileSet) */ {
 public:
  CloudStorageRegexFileSet();
  virtual ~CloudStorageRegexFileSet();

  CloudStorageRegexFileSet(const CloudStorageRegexFileSet& from);

  inline CloudStorageRegexFileSet& operator=(const CloudStorageRegexFileSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudStorageRegexFileSet(CloudStorageRegexFileSet&& from) noexcept
    : CloudStorageRegexFileSet() {
    *this = ::std::move(from);
  }

  inline CloudStorageRegexFileSet& operator=(CloudStorageRegexFileSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudStorageRegexFileSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudStorageRegexFileSet* internal_default_instance() {
    return reinterpret_cast<const CloudStorageRegexFileSet*>(
               &_CloudStorageRegexFileSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CloudStorageRegexFileSet* other);
  friend void swap(CloudStorageRegexFileSet& a, CloudStorageRegexFileSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudStorageRegexFileSet* New() const final {
    return CreateMaybeMessage<CloudStorageRegexFileSet>(nullptr);
  }

  CloudStorageRegexFileSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudStorageRegexFileSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudStorageRegexFileSet& from);
  void MergeFrom(const CloudStorageRegexFileSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudStorageRegexFileSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string include_regex = 2;
  int include_regex_size() const;
  void clear_include_regex();
  static const int kIncludeRegexFieldNumber = 2;
  const ::std::string& include_regex(int index) const;
  ::std::string* mutable_include_regex(int index);
  void set_include_regex(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_include_regex(int index, ::std::string&& value);
  #endif
  void set_include_regex(int index, const char* value);
  void set_include_regex(int index, const char* value, size_t size);
  ::std::string* add_include_regex();
  void add_include_regex(const ::std::string& value);
  #if LANG_CXX11
  void add_include_regex(::std::string&& value);
  #endif
  void add_include_regex(const char* value);
  void add_include_regex(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& include_regex() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_include_regex();

  // repeated string exclude_regex = 3;
  int exclude_regex_size() const;
  void clear_exclude_regex();
  static const int kExcludeRegexFieldNumber = 3;
  const ::std::string& exclude_regex(int index) const;
  ::std::string* mutable_exclude_regex(int index);
  void set_exclude_regex(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_exclude_regex(int index, ::std::string&& value);
  #endif
  void set_exclude_regex(int index, const char* value);
  void set_exclude_regex(int index, const char* value, size_t size);
  ::std::string* add_exclude_regex();
  void add_exclude_regex(const ::std::string& value);
  #if LANG_CXX11
  void add_exclude_regex(::std::string&& value);
  #endif
  void add_exclude_regex(const char* value);
  void add_exclude_regex(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& exclude_regex() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_exclude_regex();

  // string bucket_name = 1;
  void clear_bucket_name();
  static const int kBucketNameFieldNumber = 1;
  const ::std::string& bucket_name() const;
  void set_bucket_name(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket_name(::std::string&& value);
  #endif
  void set_bucket_name(const char* value);
  void set_bucket_name(const char* value, size_t size);
  ::std::string* mutable_bucket_name();
  ::std::string* release_bucket_name();
  void set_allocated_bucket_name(::std::string* bucket_name);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CloudStorageRegexFileSet)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> include_regex_;
  ::google::protobuf::RepeatedPtrField<::std::string> exclude_regex_;
  ::google::protobuf::internal::ArenaStringPtr bucket_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CloudStorageOptions_FileSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CloudStorageOptions.FileSet) */ {
 public:
  CloudStorageOptions_FileSet();
  virtual ~CloudStorageOptions_FileSet();

  CloudStorageOptions_FileSet(const CloudStorageOptions_FileSet& from);

  inline CloudStorageOptions_FileSet& operator=(const CloudStorageOptions_FileSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudStorageOptions_FileSet(CloudStorageOptions_FileSet&& from) noexcept
    : CloudStorageOptions_FileSet() {
    *this = ::std::move(from);
  }

  inline CloudStorageOptions_FileSet& operator=(CloudStorageOptions_FileSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudStorageOptions_FileSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudStorageOptions_FileSet* internal_default_instance() {
    return reinterpret_cast<const CloudStorageOptions_FileSet*>(
               &_CloudStorageOptions_FileSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CloudStorageOptions_FileSet* other);
  friend void swap(CloudStorageOptions_FileSet& a, CloudStorageOptions_FileSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudStorageOptions_FileSet* New() const final {
    return CreateMaybeMessage<CloudStorageOptions_FileSet>(nullptr);
  }

  CloudStorageOptions_FileSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudStorageOptions_FileSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudStorageOptions_FileSet& from);
  void MergeFrom(const CloudStorageOptions_FileSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudStorageOptions_FileSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // .google.privacy.dlp.v2.CloudStorageRegexFileSet regex_file_set = 2;
  bool has_regex_file_set() const;
  void clear_regex_file_set();
  static const int kRegexFileSetFieldNumber = 2;
  const ::google::privacy::dlp::v2::CloudStorageRegexFileSet& regex_file_set() const;
  ::google::privacy::dlp::v2::CloudStorageRegexFileSet* release_regex_file_set();
  ::google::privacy::dlp::v2::CloudStorageRegexFileSet* mutable_regex_file_set();
  void set_allocated_regex_file_set(::google::privacy::dlp::v2::CloudStorageRegexFileSet* regex_file_set);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CloudStorageOptions.FileSet)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::privacy::dlp::v2::CloudStorageRegexFileSet* regex_file_set_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CloudStorageOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CloudStorageOptions) */ {
 public:
  CloudStorageOptions();
  virtual ~CloudStorageOptions();

  CloudStorageOptions(const CloudStorageOptions& from);

  inline CloudStorageOptions& operator=(const CloudStorageOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudStorageOptions(CloudStorageOptions&& from) noexcept
    : CloudStorageOptions() {
    *this = ::std::move(from);
  }

  inline CloudStorageOptions& operator=(CloudStorageOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudStorageOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudStorageOptions* internal_default_instance() {
    return reinterpret_cast<const CloudStorageOptions*>(
               &_CloudStorageOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CloudStorageOptions* other);
  friend void swap(CloudStorageOptions& a, CloudStorageOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudStorageOptions* New() const final {
    return CreateMaybeMessage<CloudStorageOptions>(nullptr);
  }

  CloudStorageOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudStorageOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudStorageOptions& from);
  void MergeFrom(const CloudStorageOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudStorageOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CloudStorageOptions_FileSet FileSet;

  typedef CloudStorageOptions_SampleMethod SampleMethod;
  static const SampleMethod SAMPLE_METHOD_UNSPECIFIED =
    CloudStorageOptions_SampleMethod_SAMPLE_METHOD_UNSPECIFIED;
  static const SampleMethod TOP =
    CloudStorageOptions_SampleMethod_TOP;
  static const SampleMethod RANDOM_START =
    CloudStorageOptions_SampleMethod_RANDOM_START;
  static inline bool SampleMethod_IsValid(int value) {
    return CloudStorageOptions_SampleMethod_IsValid(value);
  }
  static const SampleMethod SampleMethod_MIN =
    CloudStorageOptions_SampleMethod_SampleMethod_MIN;
  static const SampleMethod SampleMethod_MAX =
    CloudStorageOptions_SampleMethod_SampleMethod_MAX;
  static const int SampleMethod_ARRAYSIZE =
    CloudStorageOptions_SampleMethod_SampleMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SampleMethod_descriptor() {
    return CloudStorageOptions_SampleMethod_descriptor();
  }
  static inline const ::std::string& SampleMethod_Name(SampleMethod value) {
    return CloudStorageOptions_SampleMethod_Name(value);
  }
  static inline bool SampleMethod_Parse(const ::std::string& name,
      SampleMethod* value) {
    return CloudStorageOptions_SampleMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .google.privacy.dlp.v2.FileType file_types = 5;
  int file_types_size() const;
  void clear_file_types();
  static const int kFileTypesFieldNumber = 5;
  ::google::privacy::dlp::v2::FileType file_types(int index) const;
  void set_file_types(int index, ::google::privacy::dlp::v2::FileType value);
  void add_file_types(::google::privacy::dlp::v2::FileType value);
  const ::google::protobuf::RepeatedField<int>& file_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_file_types();

  // .google.privacy.dlp.v2.CloudStorageOptions.FileSet file_set = 1;
  bool has_file_set() const;
  void clear_file_set();
  static const int kFileSetFieldNumber = 1;
  const ::google::privacy::dlp::v2::CloudStorageOptions_FileSet& file_set() const;
  ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* release_file_set();
  ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* mutable_file_set();
  void set_allocated_file_set(::google::privacy::dlp::v2::CloudStorageOptions_FileSet* file_set);

  // int64 bytes_limit_per_file = 4;
  void clear_bytes_limit_per_file();
  static const int kBytesLimitPerFileFieldNumber = 4;
  ::google::protobuf::int64 bytes_limit_per_file() const;
  void set_bytes_limit_per_file(::google::protobuf::int64 value);

  // .google.privacy.dlp.v2.CloudStorageOptions.SampleMethod sample_method = 6;
  void clear_sample_method();
  static const int kSampleMethodFieldNumber = 6;
  ::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod sample_method() const;
  void set_sample_method(::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod value);

  // int32 files_limit_percent = 7;
  void clear_files_limit_percent();
  static const int kFilesLimitPercentFieldNumber = 7;
  ::google::protobuf::int32 files_limit_percent() const;
  void set_files_limit_percent(::google::protobuf::int32 value);

  // int32 bytes_limit_per_file_percent = 8;
  void clear_bytes_limit_per_file_percent();
  static const int kBytesLimitPerFilePercentFieldNumber = 8;
  ::google::protobuf::int32 bytes_limit_per_file_percent() const;
  void set_bytes_limit_per_file_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CloudStorageOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> file_types_;
  mutable std::atomic<int> _file_types_cached_byte_size_;
  ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* file_set_;
  ::google::protobuf::int64 bytes_limit_per_file_;
  int sample_method_;
  ::google::protobuf::int32 files_limit_percent_;
  ::google::protobuf::int32 bytes_limit_per_file_percent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CloudStorageFileSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CloudStorageFileSet) */ {
 public:
  CloudStorageFileSet();
  virtual ~CloudStorageFileSet();

  CloudStorageFileSet(const CloudStorageFileSet& from);

  inline CloudStorageFileSet& operator=(const CloudStorageFileSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudStorageFileSet(CloudStorageFileSet&& from) noexcept
    : CloudStorageFileSet() {
    *this = ::std::move(from);
  }

  inline CloudStorageFileSet& operator=(CloudStorageFileSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudStorageFileSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudStorageFileSet* internal_default_instance() {
    return reinterpret_cast<const CloudStorageFileSet*>(
               &_CloudStorageFileSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CloudStorageFileSet* other);
  friend void swap(CloudStorageFileSet& a, CloudStorageFileSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudStorageFileSet* New() const final {
    return CreateMaybeMessage<CloudStorageFileSet>(nullptr);
  }

  CloudStorageFileSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudStorageFileSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudStorageFileSet& from);
  void MergeFrom(const CloudStorageFileSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudStorageFileSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CloudStorageFileSet)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CloudStoragePath final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.CloudStoragePath) */ {
 public:
  CloudStoragePath();
  virtual ~CloudStoragePath();

  CloudStoragePath(const CloudStoragePath& from);

  inline CloudStoragePath& operator=(const CloudStoragePath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudStoragePath(CloudStoragePath&& from) noexcept
    : CloudStoragePath() {
    *this = ::std::move(from);
  }

  inline CloudStoragePath& operator=(CloudStoragePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudStoragePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudStoragePath* internal_default_instance() {
    return reinterpret_cast<const CloudStoragePath*>(
               &_CloudStoragePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CloudStoragePath* other);
  friend void swap(CloudStoragePath& a, CloudStoragePath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudStoragePath* New() const final {
    return CreateMaybeMessage<CloudStoragePath>(nullptr);
  }

  CloudStoragePath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudStoragePath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudStoragePath& from);
  void MergeFrom(const CloudStoragePath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudStoragePath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.CloudStoragePath)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class BigQueryOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.BigQueryOptions) */ {
 public:
  BigQueryOptions();
  virtual ~BigQueryOptions();

  BigQueryOptions(const BigQueryOptions& from);

  inline BigQueryOptions& operator=(const BigQueryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigQueryOptions(BigQueryOptions&& from) noexcept
    : BigQueryOptions() {
    *this = ::std::move(from);
  }

  inline BigQueryOptions& operator=(BigQueryOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BigQueryOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigQueryOptions* internal_default_instance() {
    return reinterpret_cast<const BigQueryOptions*>(
               &_BigQueryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(BigQueryOptions* other);
  friend void swap(BigQueryOptions& a, BigQueryOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigQueryOptions* New() const final {
    return CreateMaybeMessage<BigQueryOptions>(nullptr);
  }

  BigQueryOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigQueryOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigQueryOptions& from);
  void MergeFrom(const BigQueryOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigQueryOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BigQueryOptions_SampleMethod SampleMethod;
  static const SampleMethod SAMPLE_METHOD_UNSPECIFIED =
    BigQueryOptions_SampleMethod_SAMPLE_METHOD_UNSPECIFIED;
  static const SampleMethod TOP =
    BigQueryOptions_SampleMethod_TOP;
  static const SampleMethod RANDOM_START =
    BigQueryOptions_SampleMethod_RANDOM_START;
  static inline bool SampleMethod_IsValid(int value) {
    return BigQueryOptions_SampleMethod_IsValid(value);
  }
  static const SampleMethod SampleMethod_MIN =
    BigQueryOptions_SampleMethod_SampleMethod_MIN;
  static const SampleMethod SampleMethod_MAX =
    BigQueryOptions_SampleMethod_SampleMethod_MAX;
  static const int SampleMethod_ARRAYSIZE =
    BigQueryOptions_SampleMethod_SampleMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SampleMethod_descriptor() {
    return BigQueryOptions_SampleMethod_descriptor();
  }
  static inline const ::std::string& SampleMethod_Name(SampleMethod value) {
    return BigQueryOptions_SampleMethod_Name(value);
  }
  static inline bool SampleMethod_Parse(const ::std::string& name,
      SampleMethod* value) {
    return BigQueryOptions_SampleMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .google.privacy.dlp.v2.FieldId identifying_fields = 2;
  int identifying_fields_size() const;
  void clear_identifying_fields();
  static const int kIdentifyingFieldsFieldNumber = 2;
  ::google::privacy::dlp::v2::FieldId* mutable_identifying_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >*
      mutable_identifying_fields();
  const ::google::privacy::dlp::v2::FieldId& identifying_fields(int index) const;
  ::google::privacy::dlp::v2::FieldId* add_identifying_fields();
  const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >&
      identifying_fields() const;

  // repeated .google.privacy.dlp.v2.FieldId excluded_fields = 5;
  int excluded_fields_size() const;
  void clear_excluded_fields();
  static const int kExcludedFieldsFieldNumber = 5;
  ::google::privacy::dlp::v2::FieldId* mutable_excluded_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >*
      mutable_excluded_fields();
  const ::google::privacy::dlp::v2::FieldId& excluded_fields(int index) const;
  ::google::privacy::dlp::v2::FieldId* add_excluded_fields();
  const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >&
      excluded_fields() const;

  // .google.privacy.dlp.v2.BigQueryTable table_reference = 1;
  bool has_table_reference() const;
  void clear_table_reference();
  static const int kTableReferenceFieldNumber = 1;
  const ::google::privacy::dlp::v2::BigQueryTable& table_reference() const;
  ::google::privacy::dlp::v2::BigQueryTable* release_table_reference();
  ::google::privacy::dlp::v2::BigQueryTable* mutable_table_reference();
  void set_allocated_table_reference(::google::privacy::dlp::v2::BigQueryTable* table_reference);

  // int64 rows_limit = 3;
  void clear_rows_limit();
  static const int kRowsLimitFieldNumber = 3;
  ::google::protobuf::int64 rows_limit() const;
  void set_rows_limit(::google::protobuf::int64 value);

  // .google.privacy.dlp.v2.BigQueryOptions.SampleMethod sample_method = 4;
  void clear_sample_method();
  static const int kSampleMethodFieldNumber = 4;
  ::google::privacy::dlp::v2::BigQueryOptions_SampleMethod sample_method() const;
  void set_sample_method(::google::privacy::dlp::v2::BigQueryOptions_SampleMethod value);

  // int32 rows_limit_percent = 6;
  void clear_rows_limit_percent();
  static const int kRowsLimitPercentFieldNumber = 6;
  ::google::protobuf::int32 rows_limit_percent() const;
  void set_rows_limit_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.BigQueryOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId > identifying_fields_;
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId > excluded_fields_;
  ::google::privacy::dlp::v2::BigQueryTable* table_reference_;
  ::google::protobuf::int64 rows_limit_;
  int sample_method_;
  ::google::protobuf::int32 rows_limit_percent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class StorageConfig_TimespanConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.StorageConfig.TimespanConfig) */ {
 public:
  StorageConfig_TimespanConfig();
  virtual ~StorageConfig_TimespanConfig();

  StorageConfig_TimespanConfig(const StorageConfig_TimespanConfig& from);

  inline StorageConfig_TimespanConfig& operator=(const StorageConfig_TimespanConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageConfig_TimespanConfig(StorageConfig_TimespanConfig&& from) noexcept
    : StorageConfig_TimespanConfig() {
    *this = ::std::move(from);
  }

  inline StorageConfig_TimespanConfig& operator=(StorageConfig_TimespanConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StorageConfig_TimespanConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageConfig_TimespanConfig* internal_default_instance() {
    return reinterpret_cast<const StorageConfig_TimespanConfig*>(
               &_StorageConfig_TimespanConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(StorageConfig_TimespanConfig* other);
  friend void swap(StorageConfig_TimespanConfig& a, StorageConfig_TimespanConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageConfig_TimespanConfig* New() const final {
    return CreateMaybeMessage<StorageConfig_TimespanConfig>(nullptr);
  }

  StorageConfig_TimespanConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageConfig_TimespanConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageConfig_TimespanConfig& from);
  void MergeFrom(const StorageConfig_TimespanConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageConfig_TimespanConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  const ::google::protobuf::Timestamp& start_time() const;
  ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* start_time);

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  const ::google::protobuf::Timestamp& end_time() const;
  ::google::protobuf::Timestamp* release_end_time();
  ::google::protobuf::Timestamp* mutable_end_time();
  void set_allocated_end_time(::google::protobuf::Timestamp* end_time);

  // .google.privacy.dlp.v2.FieldId timestamp_field = 3;
  bool has_timestamp_field() const;
  void clear_timestamp_field();
  static const int kTimestampFieldFieldNumber = 3;
  const ::google::privacy::dlp::v2::FieldId& timestamp_field() const;
  ::google::privacy::dlp::v2::FieldId* release_timestamp_field();
  ::google::privacy::dlp::v2::FieldId* mutable_timestamp_field();
  void set_allocated_timestamp_field(::google::privacy::dlp::v2::FieldId* timestamp_field);

  // bool enable_auto_population_of_timespan_config = 4;
  void clear_enable_auto_population_of_timespan_config();
  static const int kEnableAutoPopulationOfTimespanConfigFieldNumber = 4;
  bool enable_auto_population_of_timespan_config() const;
  void set_enable_auto_population_of_timespan_config(bool value);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.StorageConfig.TimespanConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* start_time_;
  ::google::protobuf::Timestamp* end_time_;
  ::google::privacy::dlp::v2::FieldId* timestamp_field_;
  bool enable_auto_population_of_timespan_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class StorageConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.StorageConfig) */ {
 public:
  StorageConfig();
  virtual ~StorageConfig();

  StorageConfig(const StorageConfig& from);

  inline StorageConfig& operator=(const StorageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageConfig(StorageConfig&& from) noexcept
    : StorageConfig() {
    *this = ::std::move(from);
  }

  inline StorageConfig& operator=(StorageConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StorageConfig& default_instance();

  enum TypeCase {
    kDatastoreOptions = 2,
    kCloudStorageOptions = 3,
    kBigQueryOptions = 4,
    kHybridOptions = 9,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageConfig* internal_default_instance() {
    return reinterpret_cast<const StorageConfig*>(
               &_StorageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(StorageConfig* other);
  friend void swap(StorageConfig& a, StorageConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageConfig* New() const final {
    return CreateMaybeMessage<StorageConfig>(nullptr);
  }

  StorageConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StorageConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StorageConfig& from);
  void MergeFrom(const StorageConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StorageConfig_TimespanConfig TimespanConfig;

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.StorageConfig.TimespanConfig timespan_config = 6;
  bool has_timespan_config() const;
  void clear_timespan_config();
  static const int kTimespanConfigFieldNumber = 6;
  const ::google::privacy::dlp::v2::StorageConfig_TimespanConfig& timespan_config() const;
  ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* release_timespan_config();
  ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* mutable_timespan_config();
  void set_allocated_timespan_config(::google::privacy::dlp::v2::StorageConfig_TimespanConfig* timespan_config);

  // .google.privacy.dlp.v2.DatastoreOptions datastore_options = 2;
  bool has_datastore_options() const;
  void clear_datastore_options();
  static const int kDatastoreOptionsFieldNumber = 2;
  const ::google::privacy::dlp::v2::DatastoreOptions& datastore_options() const;
  ::google::privacy::dlp::v2::DatastoreOptions* release_datastore_options();
  ::google::privacy::dlp::v2::DatastoreOptions* mutable_datastore_options();
  void set_allocated_datastore_options(::google::privacy::dlp::v2::DatastoreOptions* datastore_options);

  // .google.privacy.dlp.v2.CloudStorageOptions cloud_storage_options = 3;
  bool has_cloud_storage_options() const;
  void clear_cloud_storage_options();
  static const int kCloudStorageOptionsFieldNumber = 3;
  const ::google::privacy::dlp::v2::CloudStorageOptions& cloud_storage_options() const;
  ::google::privacy::dlp::v2::CloudStorageOptions* release_cloud_storage_options();
  ::google::privacy::dlp::v2::CloudStorageOptions* mutable_cloud_storage_options();
  void set_allocated_cloud_storage_options(::google::privacy::dlp::v2::CloudStorageOptions* cloud_storage_options);

  // .google.privacy.dlp.v2.BigQueryOptions big_query_options = 4;
  bool has_big_query_options() const;
  void clear_big_query_options();
  static const int kBigQueryOptionsFieldNumber = 4;
  const ::google::privacy::dlp::v2::BigQueryOptions& big_query_options() const;
  ::google::privacy::dlp::v2::BigQueryOptions* release_big_query_options();
  ::google::privacy::dlp::v2::BigQueryOptions* mutable_big_query_options();
  void set_allocated_big_query_options(::google::privacy::dlp::v2::BigQueryOptions* big_query_options);

  // .google.privacy.dlp.v2.HybridOptions hybrid_options = 9;
  bool has_hybrid_options() const;
  void clear_hybrid_options();
  static const int kHybridOptionsFieldNumber = 9;
  const ::google::privacy::dlp::v2::HybridOptions& hybrid_options() const;
  ::google::privacy::dlp::v2::HybridOptions* release_hybrid_options();
  ::google::privacy::dlp::v2::HybridOptions* mutable_hybrid_options();
  void set_allocated_hybrid_options(::google::privacy::dlp::v2::HybridOptions* hybrid_options);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.StorageConfig)
 private:
  class HasBitSetters;
  void set_has_datastore_options();
  void set_has_cloud_storage_options();
  void set_has_big_query_options();
  void set_has_hybrid_options();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* timespan_config_;
  union TypeUnion {
    TypeUnion() {}
    ::google::privacy::dlp::v2::DatastoreOptions* datastore_options_;
    ::google::privacy::dlp::v2::CloudStorageOptions* cloud_storage_options_;
    ::google::privacy::dlp::v2::BigQueryOptions* big_query_options_;
    ::google::privacy::dlp::v2::HybridOptions* hybrid_options_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class HybridOptions_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HybridOptions_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<HybridOptions_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HybridOptions_LabelsEntry_DoNotUse();
  HybridOptions_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HybridOptions_LabelsEntry_DoNotUse& other);
  static const HybridOptions_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HybridOptions_LabelsEntry_DoNotUse*>(&_HybridOptions_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HybridOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.HybridOptions) */ {
 public:
  HybridOptions();
  virtual ~HybridOptions();

  HybridOptions(const HybridOptions& from);

  inline HybridOptions& operator=(const HybridOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HybridOptions(HybridOptions&& from) noexcept
    : HybridOptions() {
    *this = ::std::move(from);
  }

  inline HybridOptions& operator=(HybridOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HybridOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HybridOptions* internal_default_instance() {
    return reinterpret_cast<const HybridOptions*>(
               &_HybridOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(HybridOptions* other);
  friend void swap(HybridOptions& a, HybridOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HybridOptions* New() const final {
    return CreateMaybeMessage<HybridOptions>(nullptr);
  }

  HybridOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HybridOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HybridOptions& from);
  void MergeFrom(const HybridOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HybridOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string required_finding_label_keys = 2;
  int required_finding_label_keys_size() const;
  void clear_required_finding_label_keys();
  static const int kRequiredFindingLabelKeysFieldNumber = 2;
  const ::std::string& required_finding_label_keys(int index) const;
  ::std::string* mutable_required_finding_label_keys(int index);
  void set_required_finding_label_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_required_finding_label_keys(int index, ::std::string&& value);
  #endif
  void set_required_finding_label_keys(int index, const char* value);
  void set_required_finding_label_keys(int index, const char* value, size_t size);
  ::std::string* add_required_finding_label_keys();
  void add_required_finding_label_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_required_finding_label_keys(::std::string&& value);
  #endif
  void add_required_finding_label_keys(const char* value);
  void add_required_finding_label_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& required_finding_label_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_required_finding_label_keys();

  // map<string, string> labels = 3;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .google.privacy.dlp.v2.TableOptions table_options = 4;
  bool has_table_options() const;
  void clear_table_options();
  static const int kTableOptionsFieldNumber = 4;
  const ::google::privacy::dlp::v2::TableOptions& table_options() const;
  ::google::privacy::dlp::v2::TableOptions* release_table_options();
  ::google::privacy::dlp::v2::TableOptions* mutable_table_options();
  void set_allocated_table_options(::google::privacy::dlp::v2::TableOptions* table_options);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.HybridOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> required_finding_label_keys_;
  ::google::protobuf::internal::MapField<
      HybridOptions_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::privacy::dlp::v2::TableOptions* table_options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class BigQueryKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.BigQueryKey) */ {
 public:
  BigQueryKey();
  virtual ~BigQueryKey();

  BigQueryKey(const BigQueryKey& from);

  inline BigQueryKey& operator=(const BigQueryKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigQueryKey(BigQueryKey&& from) noexcept
    : BigQueryKey() {
    *this = ::std::move(from);
  }

  inline BigQueryKey& operator=(BigQueryKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BigQueryKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigQueryKey* internal_default_instance() {
    return reinterpret_cast<const BigQueryKey*>(
               &_BigQueryKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(BigQueryKey* other);
  friend void swap(BigQueryKey& a, BigQueryKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigQueryKey* New() const final {
    return CreateMaybeMessage<BigQueryKey>(nullptr);
  }

  BigQueryKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigQueryKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigQueryKey& from);
  void MergeFrom(const BigQueryKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigQueryKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.BigQueryTable table_reference = 1;
  bool has_table_reference() const;
  void clear_table_reference();
  static const int kTableReferenceFieldNumber = 1;
  const ::google::privacy::dlp::v2::BigQueryTable& table_reference() const;
  ::google::privacy::dlp::v2::BigQueryTable* release_table_reference();
  ::google::privacy::dlp::v2::BigQueryTable* mutable_table_reference();
  void set_allocated_table_reference(::google::privacy::dlp::v2::BigQueryTable* table_reference);

  // int64 row_number = 2;
  void clear_row_number();
  static const int kRowNumberFieldNumber = 2;
  ::google::protobuf::int64 row_number() const;
  void set_row_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.BigQueryKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::BigQueryTable* table_reference_;
  ::google::protobuf::int64 row_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class DatastoreKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.DatastoreKey) */ {
 public:
  DatastoreKey();
  virtual ~DatastoreKey();

  DatastoreKey(const DatastoreKey& from);

  inline DatastoreKey& operator=(const DatastoreKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatastoreKey(DatastoreKey&& from) noexcept
    : DatastoreKey() {
    *this = ::std::move(from);
  }

  inline DatastoreKey& operator=(DatastoreKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DatastoreKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatastoreKey* internal_default_instance() {
    return reinterpret_cast<const DatastoreKey*>(
               &_DatastoreKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(DatastoreKey* other);
  friend void swap(DatastoreKey& a, DatastoreKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatastoreKey* New() const final {
    return CreateMaybeMessage<DatastoreKey>(nullptr);
  }

  DatastoreKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatastoreKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatastoreKey& from);
  void MergeFrom(const DatastoreKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatastoreKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.Key entity_key = 1;
  bool has_entity_key() const;
  void clear_entity_key();
  static const int kEntityKeyFieldNumber = 1;
  const ::google::privacy::dlp::v2::Key& entity_key() const;
  ::google::privacy::dlp::v2::Key* release_entity_key();
  ::google::privacy::dlp::v2::Key* mutable_entity_key();
  void set_allocated_entity_key(::google::privacy::dlp::v2::Key* entity_key);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.DatastoreKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::Key* entity_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class Key_PathElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.Key.PathElement) */ {
 public:
  Key_PathElement();
  virtual ~Key_PathElement();

  Key_PathElement(const Key_PathElement& from);

  inline Key_PathElement& operator=(const Key_PathElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Key_PathElement(Key_PathElement&& from) noexcept
    : Key_PathElement() {
    *this = ::std::move(from);
  }

  inline Key_PathElement& operator=(Key_PathElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Key_PathElement& default_instance();

  enum IdTypeCase {
    kId = 2,
    kName = 3,
    ID_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Key_PathElement* internal_default_instance() {
    return reinterpret_cast<const Key_PathElement*>(
               &_Key_PathElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Key_PathElement* other);
  friend void swap(Key_PathElement& a, Key_PathElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Key_PathElement* New() const final {
    return CreateMaybeMessage<Key_PathElement>(nullptr);
  }

  Key_PathElement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Key_PathElement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Key_PathElement& from);
  void MergeFrom(const Key_PathElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key_PathElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  const ::std::string& kind() const;
  void set_kind(const ::std::string& value);
  #if LANG_CXX11
  void set_kind(::std::string&& value);
  #endif
  void set_kind(const char* value);
  void set_kind(const char* value, size_t size);
  ::std::string* mutable_kind();
  ::std::string* release_kind();
  void set_allocated_kind(::std::string* kind);

  // int64 id = 2;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // string name = 3;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  void clear_id_type();
  IdTypeCase id_type_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.Key.PathElement)
 private:
  class HasBitSetters;
  void set_has_id();
  void set_has_name();

  inline bool has_id_type() const;
  inline void clear_has_id_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr kind_;
  union IdTypeUnion {
    IdTypeUnion() {}
    ::google::protobuf::int64 id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
  } id_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class Key final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.Key) */ {
 public:
  Key();
  virtual ~Key();

  Key(const Key& from);

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Key(Key&& from) noexcept
    : Key() {
    *this = ::std::move(from);
  }

  inline Key& operator=(Key&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Key& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Key* internal_default_instance() {
    return reinterpret_cast<const Key*>(
               &_Key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Key* other);
  friend void swap(Key& a, Key& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Key* New() const final {
    return CreateMaybeMessage<Key>(nullptr);
  }

  Key* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Key>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Key_PathElement PathElement;

  // accessors -------------------------------------------------------

  // repeated .google.privacy.dlp.v2.Key.PathElement path = 2;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  ::google::privacy::dlp::v2::Key_PathElement* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::Key_PathElement >*
      mutable_path();
  const ::google::privacy::dlp::v2::Key_PathElement& path(int index) const;
  ::google::privacy::dlp::v2::Key_PathElement* add_path();
  const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::Key_PathElement >&
      path() const;

  // .google.privacy.dlp.v2.PartitionId partition_id = 1;
  bool has_partition_id() const;
  void clear_partition_id();
  static const int kPartitionIdFieldNumber = 1;
  const ::google::privacy::dlp::v2::PartitionId& partition_id() const;
  ::google::privacy::dlp::v2::PartitionId* release_partition_id();
  ::google::privacy::dlp::v2::PartitionId* mutable_partition_id();
  void set_allocated_partition_id(::google::privacy::dlp::v2::PartitionId* partition_id);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.Key)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::Key_PathElement > path_;
  ::google::privacy::dlp::v2::PartitionId* partition_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class RecordKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.RecordKey) */ {
 public:
  RecordKey();
  virtual ~RecordKey();

  RecordKey(const RecordKey& from);

  inline RecordKey& operator=(const RecordKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordKey(RecordKey&& from) noexcept
    : RecordKey() {
    *this = ::std::move(from);
  }

  inline RecordKey& operator=(RecordKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecordKey& default_instance();

  enum TypeCase {
    kDatastoreKey = 2,
    kBigQueryKey = 3,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordKey* internal_default_instance() {
    return reinterpret_cast<const RecordKey*>(
               &_RecordKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(RecordKey* other);
  friend void swap(RecordKey& a, RecordKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordKey* New() const final {
    return CreateMaybeMessage<RecordKey>(nullptr);
  }

  RecordKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecordKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecordKey& from);
  void MergeFrom(const RecordKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string id_values = 5;
  int id_values_size() const;
  void clear_id_values();
  static const int kIdValuesFieldNumber = 5;
  const ::std::string& id_values(int index) const;
  ::std::string* mutable_id_values(int index);
  void set_id_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_id_values(int index, ::std::string&& value);
  #endif
  void set_id_values(int index, const char* value);
  void set_id_values(int index, const char* value, size_t size);
  ::std::string* add_id_values();
  void add_id_values(const ::std::string& value);
  #if LANG_CXX11
  void add_id_values(::std::string&& value);
  #endif
  void add_id_values(const char* value);
  void add_id_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& id_values() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_id_values();

  // .google.privacy.dlp.v2.DatastoreKey datastore_key = 2;
  bool has_datastore_key() const;
  void clear_datastore_key();
  static const int kDatastoreKeyFieldNumber = 2;
  const ::google::privacy::dlp::v2::DatastoreKey& datastore_key() const;
  ::google::privacy::dlp::v2::DatastoreKey* release_datastore_key();
  ::google::privacy::dlp::v2::DatastoreKey* mutable_datastore_key();
  void set_allocated_datastore_key(::google::privacy::dlp::v2::DatastoreKey* datastore_key);

  // .google.privacy.dlp.v2.BigQueryKey big_query_key = 3;
  bool has_big_query_key() const;
  void clear_big_query_key();
  static const int kBigQueryKeyFieldNumber = 3;
  const ::google::privacy::dlp::v2::BigQueryKey& big_query_key() const;
  ::google::privacy::dlp::v2::BigQueryKey* release_big_query_key();
  ::google::privacy::dlp::v2::BigQueryKey* mutable_big_query_key();
  void set_allocated_big_query_key(::google::privacy::dlp::v2::BigQueryKey* big_query_key);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.RecordKey)
 private:
  class HasBitSetters;
  void set_has_datastore_key();
  void set_has_big_query_key();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> id_values_;
  union TypeUnion {
    TypeUnion() {}
    ::google::privacy::dlp::v2::DatastoreKey* datastore_key_;
    ::google::privacy::dlp::v2::BigQueryKey* big_query_key_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class BigQueryTable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.BigQueryTable) */ {
 public:
  BigQueryTable();
  virtual ~BigQueryTable();

  BigQueryTable(const BigQueryTable& from);

  inline BigQueryTable& operator=(const BigQueryTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigQueryTable(BigQueryTable&& from) noexcept
    : BigQueryTable() {
    *this = ::std::move(from);
  }

  inline BigQueryTable& operator=(BigQueryTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BigQueryTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigQueryTable* internal_default_instance() {
    return reinterpret_cast<const BigQueryTable*>(
               &_BigQueryTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(BigQueryTable* other);
  friend void swap(BigQueryTable& a, BigQueryTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigQueryTable* New() const final {
    return CreateMaybeMessage<BigQueryTable>(nullptr);
  }

  BigQueryTable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigQueryTable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigQueryTable& from);
  void MergeFrom(const BigQueryTable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigQueryTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project_id = 1;
  void clear_project_id();
  static const int kProjectIdFieldNumber = 1;
  const ::std::string& project_id() const;
  void set_project_id(const ::std::string& value);
  #if LANG_CXX11
  void set_project_id(::std::string&& value);
  #endif
  void set_project_id(const char* value);
  void set_project_id(const char* value, size_t size);
  ::std::string* mutable_project_id();
  ::std::string* release_project_id();
  void set_allocated_project_id(::std::string* project_id);

  // string dataset_id = 2;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 2;
  const ::std::string& dataset_id() const;
  void set_dataset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_dataset_id(::std::string&& value);
  #endif
  void set_dataset_id(const char* value);
  void set_dataset_id(const char* value, size_t size);
  ::std::string* mutable_dataset_id();
  ::std::string* release_dataset_id();
  void set_allocated_dataset_id(::std::string* dataset_id);

  // string table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  const ::std::string& table_id() const;
  void set_table_id(const ::std::string& value);
  #if LANG_CXX11
  void set_table_id(::std::string&& value);
  #endif
  void set_table_id(const char* value);
  void set_table_id(const char* value, size_t size);
  ::std::string* mutable_table_id();
  ::std::string* release_table_id();
  void set_allocated_table_id(::std::string* table_id);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.BigQueryTable)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_id_;
  ::google::protobuf::internal::ArenaStringPtr dataset_id_;
  ::google::protobuf::internal::ArenaStringPtr table_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class BigQueryField final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.BigQueryField) */ {
 public:
  BigQueryField();
  virtual ~BigQueryField();

  BigQueryField(const BigQueryField& from);

  inline BigQueryField& operator=(const BigQueryField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigQueryField(BigQueryField&& from) noexcept
    : BigQueryField() {
    *this = ::std::move(from);
  }

  inline BigQueryField& operator=(BigQueryField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BigQueryField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigQueryField* internal_default_instance() {
    return reinterpret_cast<const BigQueryField*>(
               &_BigQueryField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(BigQueryField* other);
  friend void swap(BigQueryField& a, BigQueryField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigQueryField* New() const final {
    return CreateMaybeMessage<BigQueryField>(nullptr);
  }

  BigQueryField* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigQueryField>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigQueryField& from);
  void MergeFrom(const BigQueryField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigQueryField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.BigQueryTable table = 1;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const ::google::privacy::dlp::v2::BigQueryTable& table() const;
  ::google::privacy::dlp::v2::BigQueryTable* release_table();
  ::google::privacy::dlp::v2::BigQueryTable* mutable_table();
  void set_allocated_table(::google::privacy::dlp::v2::BigQueryTable* table);

  // .google.privacy.dlp.v2.FieldId field = 2;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::google::privacy::dlp::v2::FieldId& field() const;
  ::google::privacy::dlp::v2::FieldId* release_field();
  ::google::privacy::dlp::v2::FieldId* mutable_field();
  void set_allocated_field(::google::privacy::dlp::v2::FieldId* field);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.BigQueryField)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::BigQueryTable* table_;
  ::google::privacy::dlp::v2::FieldId* field_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class EntityId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.EntityId) */ {
 public:
  EntityId();
  virtual ~EntityId();

  EntityId(const EntityId& from);

  inline EntityId& operator=(const EntityId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityId(EntityId&& from) noexcept
    : EntityId() {
    *this = ::std::move(from);
  }

  inline EntityId& operator=(EntityId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EntityId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityId* internal_default_instance() {
    return reinterpret_cast<const EntityId*>(
               &_EntityId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(EntityId* other);
  friend void swap(EntityId& a, EntityId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityId* New() const final {
    return CreateMaybeMessage<EntityId>(nullptr);
  }

  EntityId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityId& from);
  void MergeFrom(const EntityId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.privacy.dlp.v2.FieldId field = 1;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::google::privacy::dlp::v2::FieldId& field() const;
  ::google::privacy::dlp::v2::FieldId* release_field();
  ::google::privacy::dlp::v2::FieldId* mutable_field();
  void set_allocated_field(::google::privacy::dlp::v2::FieldId* field);

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.EntityId)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::privacy::dlp::v2::FieldId* field_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class TableOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.privacy.dlp.v2.TableOptions) */ {
 public:
  TableOptions();
  virtual ~TableOptions();

  TableOptions(const TableOptions& from);

  inline TableOptions& operator=(const TableOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableOptions(TableOptions&& from) noexcept
    : TableOptions() {
    *this = ::std::move(from);
  }

  inline TableOptions& operator=(TableOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TableOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableOptions* internal_default_instance() {
    return reinterpret_cast<const TableOptions*>(
               &_TableOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(TableOptions* other);
  friend void swap(TableOptions& a, TableOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableOptions* New() const final {
    return CreateMaybeMessage<TableOptions>(nullptr);
  }

  TableOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableOptions& from);
  void MergeFrom(const TableOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.privacy.dlp.v2.FieldId identifying_fields = 1;
  int identifying_fields_size() const;
  void clear_identifying_fields();
  static const int kIdentifyingFieldsFieldNumber = 1;
  ::google::privacy::dlp::v2::FieldId* mutable_identifying_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >*
      mutable_identifying_fields();
  const ::google::privacy::dlp::v2::FieldId& identifying_fields(int index) const;
  ::google::privacy::dlp::v2::FieldId* add_identifying_fields();
  const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >&
      identifying_fields() const;

  // @@protoc_insertion_point(class_scope:google.privacy.dlp.v2.TableOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId > identifying_fields_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InfoType

// string name = 1;
inline void InfoType::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InfoType::name() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.InfoType.name)
  return name_.GetNoArena();
}
inline void InfoType::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.InfoType.name)
}
#if LANG_CXX11
inline void InfoType::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.InfoType.name)
}
#endif
inline void InfoType::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.InfoType.name)
}
inline void InfoType::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.InfoType.name)
}
inline ::std::string* InfoType::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.InfoType.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InfoType::release_name() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.InfoType.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InfoType::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.InfoType.name)
}

// -------------------------------------------------------------------

// StoredType

// string name = 1;
inline void StoredType::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StoredType::name() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StoredType.name)
  return name_.GetNoArena();
}
inline void StoredType::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.StoredType.name)
}
#if LANG_CXX11
inline void StoredType::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.StoredType.name)
}
#endif
inline void StoredType::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.StoredType.name)
}
inline void StoredType::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.StoredType.name)
}
inline ::std::string* StoredType::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StoredType.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StoredType::release_name() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StoredType.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StoredType::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.StoredType.name)
}

// .google.protobuf.Timestamp create_time = 2;
inline bool StoredType::has_create_time() const {
  return this != internal_default_instance() && create_time_ != nullptr;
}
inline const ::google::protobuf::Timestamp& StoredType::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StoredType.create_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* StoredType::release_create_time() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StoredType.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* StoredType::mutable_create_time() {
  
  if (create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StoredType.create_time)
  return create_time_;
}
inline void StoredType::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.StoredType.create_time)
}

// -------------------------------------------------------------------

// CustomInfoType_Dictionary_WordList

// repeated string words = 1;
inline int CustomInfoType_Dictionary_WordList::words_size() const {
  return words_.size();
}
inline void CustomInfoType_Dictionary_WordList::clear_words() {
  words_.Clear();
}
inline const ::std::string& CustomInfoType_Dictionary_WordList::words(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  return words_.Get(index);
}
inline ::std::string* CustomInfoType_Dictionary_WordList::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  return words_.Mutable(index);
}
inline void CustomInfoType_Dictionary_WordList::set_words(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  words_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CustomInfoType_Dictionary_WordList::set_words(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  words_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CustomInfoType_Dictionary_WordList::set_words(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  words_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
}
inline void CustomInfoType_Dictionary_WordList::set_words(int index, const char* value, size_t size) {
  words_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
}
inline ::std::string* CustomInfoType_Dictionary_WordList::add_words() {
  // @@protoc_insertion_point(field_add_mutable:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  return words_.Add();
}
inline void CustomInfoType_Dictionary_WordList::add_words(const ::std::string& value) {
  words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
}
#if LANG_CXX11
inline void CustomInfoType_Dictionary_WordList::add_words(::std::string&& value) {
  words_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
}
#endif
inline void CustomInfoType_Dictionary_WordList::add_words(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
}
inline void CustomInfoType_Dictionary_WordList::add_words(const char* value, size_t size) {
  words_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CustomInfoType_Dictionary_WordList::words() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  return words_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
CustomInfoType_Dictionary_WordList::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.words)
  return &words_;
}

// -------------------------------------------------------------------

// CustomInfoType_Dictionary

// .google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList word_list = 1;
inline bool CustomInfoType_Dictionary::has_word_list() const {
  return source_case() == kWordList;
}
inline void CustomInfoType_Dictionary::set_has_word_list() {
  _oneof_case_[0] = kWordList;
}
inline void CustomInfoType_Dictionary::clear_word_list() {
  if (has_word_list()) {
    delete source_.word_list_;
    clear_has_source();
  }
}
inline ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* CustomInfoType_Dictionary::release_word_list() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.Dictionary.word_list)
  if (has_word_list()) {
    clear_has_source();
      ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* temp = source_.word_list_;
    source_.word_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList& CustomInfoType_Dictionary::word_list() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.Dictionary.word_list)
  return has_word_list()
      ? *source_.word_list_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList*>(&::google::privacy::dlp::v2::_CustomInfoType_Dictionary_WordList_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList* CustomInfoType_Dictionary::mutable_word_list() {
  if (!has_word_list()) {
    clear_source();
    set_has_word_list();
    source_.word_list_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CustomInfoType_Dictionary_WordList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.Dictionary.word_list)
  return source_.word_list_;
}

// .google.privacy.dlp.v2.CloudStoragePath cloud_storage_path = 3;
inline bool CustomInfoType_Dictionary::has_cloud_storage_path() const {
  return source_case() == kCloudStoragePath;
}
inline void CustomInfoType_Dictionary::set_has_cloud_storage_path() {
  _oneof_case_[0] = kCloudStoragePath;
}
inline void CustomInfoType_Dictionary::clear_cloud_storage_path() {
  if (has_cloud_storage_path()) {
    delete source_.cloud_storage_path_;
    clear_has_source();
  }
}
inline ::google::privacy::dlp::v2::CloudStoragePath* CustomInfoType_Dictionary::release_cloud_storage_path() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.Dictionary.cloud_storage_path)
  if (has_cloud_storage_path()) {
    clear_has_source();
      ::google::privacy::dlp::v2::CloudStoragePath* temp = source_.cloud_storage_path_;
    source_.cloud_storage_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CloudStoragePath& CustomInfoType_Dictionary::cloud_storage_path() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.Dictionary.cloud_storage_path)
  return has_cloud_storage_path()
      ? *source_.cloud_storage_path_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CloudStoragePath*>(&::google::privacy::dlp::v2::_CloudStoragePath_default_instance_);
}
inline ::google::privacy::dlp::v2::CloudStoragePath* CustomInfoType_Dictionary::mutable_cloud_storage_path() {
  if (!has_cloud_storage_path()) {
    clear_source();
    set_has_cloud_storage_path();
    source_.cloud_storage_path_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CloudStoragePath >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.Dictionary.cloud_storage_path)
  return source_.cloud_storage_path_;
}

inline bool CustomInfoType_Dictionary::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void CustomInfoType_Dictionary::clear_has_source() {
  _oneof_case_[0] = SOURCE_NOT_SET;
}
inline CustomInfoType_Dictionary::SourceCase CustomInfoType_Dictionary::source_case() const {
  return CustomInfoType_Dictionary::SourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CustomInfoType_Regex

// string pattern = 1;
inline void CustomInfoType_Regex::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomInfoType_Regex::pattern() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
  return pattern_.GetNoArena();
}
inline void CustomInfoType_Regex::set_pattern(const ::std::string& value) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
}
#if LANG_CXX11
inline void CustomInfoType_Regex::set_pattern(::std::string&& value) {
  
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
}
#endif
inline void CustomInfoType_Regex::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
}
inline void CustomInfoType_Regex::set_pattern(const char* value, size_t size) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
}
inline ::std::string* CustomInfoType_Regex::mutable_pattern() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomInfoType_Regex::release_pattern() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
  
  return pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomInfoType_Regex::set_allocated_pattern(::std::string* pattern) {
  if (pattern != nullptr) {
    
  } else {
    
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CustomInfoType.Regex.pattern)
}

// repeated int32 group_indexes = 2;
inline int CustomInfoType_Regex::group_indexes_size() const {
  return group_indexes_.size();
}
inline void CustomInfoType_Regex::clear_group_indexes() {
  group_indexes_.Clear();
}
inline ::google::protobuf::int32 CustomInfoType_Regex::group_indexes(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.Regex.group_indexes)
  return group_indexes_.Get(index);
}
inline void CustomInfoType_Regex::set_group_indexes(int index, ::google::protobuf::int32 value) {
  group_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.Regex.group_indexes)
}
inline void CustomInfoType_Regex::add_group_indexes(::google::protobuf::int32 value) {
  group_indexes_.Add(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CustomInfoType.Regex.group_indexes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CustomInfoType_Regex::group_indexes() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.CustomInfoType.Regex.group_indexes)
  return group_indexes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CustomInfoType_Regex::mutable_group_indexes() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.CustomInfoType.Regex.group_indexes)
  return &group_indexes_;
}

// -------------------------------------------------------------------

// CustomInfoType_SurrogateType

// -------------------------------------------------------------------

// CustomInfoType_DetectionRule_Proximity

// int32 window_before = 1;
inline void CustomInfoType_DetectionRule_Proximity::clear_window_before() {
  window_before_ = 0;
}
inline ::google::protobuf::int32 CustomInfoType_DetectionRule_Proximity::window_before() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity.window_before)
  return window_before_;
}
inline void CustomInfoType_DetectionRule_Proximity::set_window_before(::google::protobuf::int32 value) {
  
  window_before_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity.window_before)
}

// int32 window_after = 2;
inline void CustomInfoType_DetectionRule_Proximity::clear_window_after() {
  window_after_ = 0;
}
inline ::google::protobuf::int32 CustomInfoType_DetectionRule_Proximity::window_after() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity.window_after)
  return window_after_;
}
inline void CustomInfoType_DetectionRule_Proximity::set_window_after(::google::protobuf::int32 value) {
  
  window_after_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity.window_after)
}

// -------------------------------------------------------------------

// CustomInfoType_DetectionRule_LikelihoodAdjustment

// .google.privacy.dlp.v2.Likelihood fixed_likelihood = 1;
inline bool CustomInfoType_DetectionRule_LikelihoodAdjustment::has_fixed_likelihood() const {
  return adjustment_case() == kFixedLikelihood;
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::set_has_fixed_likelihood() {
  _oneof_case_[0] = kFixedLikelihood;
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::clear_fixed_likelihood() {
  if (has_fixed_likelihood()) {
    adjustment_.fixed_likelihood_ = 0;
    clear_has_adjustment();
  }
}
inline ::google::privacy::dlp::v2::Likelihood CustomInfoType_DetectionRule_LikelihoodAdjustment::fixed_likelihood() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.fixed_likelihood)
  if (has_fixed_likelihood()) {
    return static_cast< ::google::privacy::dlp::v2::Likelihood >(adjustment_.fixed_likelihood_);
  }
  return static_cast< ::google::privacy::dlp::v2::Likelihood >(0);
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::set_fixed_likelihood(::google::privacy::dlp::v2::Likelihood value) {
  if (!has_fixed_likelihood()) {
    clear_adjustment();
    set_has_fixed_likelihood();
  }
  adjustment_.fixed_likelihood_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.fixed_likelihood)
}

// int32 relative_likelihood = 2;
inline bool CustomInfoType_DetectionRule_LikelihoodAdjustment::has_relative_likelihood() const {
  return adjustment_case() == kRelativeLikelihood;
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::set_has_relative_likelihood() {
  _oneof_case_[0] = kRelativeLikelihood;
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::clear_relative_likelihood() {
  if (has_relative_likelihood()) {
    adjustment_.relative_likelihood_ = 0;
    clear_has_adjustment();
  }
}
inline ::google::protobuf::int32 CustomInfoType_DetectionRule_LikelihoodAdjustment::relative_likelihood() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.relative_likelihood)
  if (has_relative_likelihood()) {
    return adjustment_.relative_likelihood_;
  }
  return 0;
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::set_relative_likelihood(::google::protobuf::int32 value) {
  if (!has_relative_likelihood()) {
    clear_adjustment();
    set_has_relative_likelihood();
  }
  adjustment_.relative_likelihood_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.relative_likelihood)
}

inline bool CustomInfoType_DetectionRule_LikelihoodAdjustment::has_adjustment() const {
  return adjustment_case() != ADJUSTMENT_NOT_SET;
}
inline void CustomInfoType_DetectionRule_LikelihoodAdjustment::clear_has_adjustment() {
  _oneof_case_[0] = ADJUSTMENT_NOT_SET;
}
inline CustomInfoType_DetectionRule_LikelihoodAdjustment::AdjustmentCase CustomInfoType_DetectionRule_LikelihoodAdjustment::adjustment_case() const {
  return CustomInfoType_DetectionRule_LikelihoodAdjustment::AdjustmentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CustomInfoType_DetectionRule_HotwordRule

// .google.privacy.dlp.v2.CustomInfoType.Regex hotword_regex = 1;
inline bool CustomInfoType_DetectionRule_HotwordRule::has_hotword_regex() const {
  return this != internal_default_instance() && hotword_regex_ != nullptr;
}
inline void CustomInfoType_DetectionRule_HotwordRule::clear_hotword_regex() {
  if (GetArenaNoVirtual() == nullptr && hotword_regex_ != nullptr) {
    delete hotword_regex_;
  }
  hotword_regex_ = nullptr;
}
inline const ::google::privacy::dlp::v2::CustomInfoType_Regex& CustomInfoType_DetectionRule_HotwordRule::hotword_regex() const {
  const ::google::privacy::dlp::v2::CustomInfoType_Regex* p = hotword_regex_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.hotword_regex)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::CustomInfoType_Regex*>(
      &::google::privacy::dlp::v2::_CustomInfoType_Regex_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_Regex* CustomInfoType_DetectionRule_HotwordRule::release_hotword_regex() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.hotword_regex)
  
  ::google::privacy::dlp::v2::CustomInfoType_Regex* temp = hotword_regex_;
  hotword_regex_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::CustomInfoType_Regex* CustomInfoType_DetectionRule_HotwordRule::mutable_hotword_regex() {
  
  if (hotword_regex_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_Regex>(GetArenaNoVirtual());
    hotword_regex_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.hotword_regex)
  return hotword_regex_;
}
inline void CustomInfoType_DetectionRule_HotwordRule::set_allocated_hotword_regex(::google::privacy::dlp::v2::CustomInfoType_Regex* hotword_regex) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hotword_regex_;
  }
  if (hotword_regex) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hotword_regex = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hotword_regex, submessage_arena);
    }
    
  } else {
    
  }
  hotword_regex_ = hotword_regex;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.hotword_regex)
}

// .google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity proximity = 2;
inline bool CustomInfoType_DetectionRule_HotwordRule::has_proximity() const {
  return this != internal_default_instance() && proximity_ != nullptr;
}
inline void CustomInfoType_DetectionRule_HotwordRule::clear_proximity() {
  if (GetArenaNoVirtual() == nullptr && proximity_ != nullptr) {
    delete proximity_;
  }
  proximity_ = nullptr;
}
inline const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity& CustomInfoType_DetectionRule_HotwordRule::proximity() const {
  const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* p = proximity_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.proximity)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity*>(
      &::google::privacy::dlp::v2::_CustomInfoType_DetectionRule_Proximity_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* CustomInfoType_DetectionRule_HotwordRule::release_proximity() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.proximity)
  
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* temp = proximity_;
  proximity_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* CustomInfoType_DetectionRule_HotwordRule::mutable_proximity() {
  
  if (proximity_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity>(GetArenaNoVirtual());
    proximity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.proximity)
  return proximity_;
}
inline void CustomInfoType_DetectionRule_HotwordRule::set_allocated_proximity(::google::privacy::dlp::v2::CustomInfoType_DetectionRule_Proximity* proximity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete proximity_;
  }
  if (proximity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proximity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proximity, submessage_arena);
    }
    
  } else {
    
  }
  proximity_ = proximity;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.proximity)
}

// .google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment likelihood_adjustment = 3;
inline bool CustomInfoType_DetectionRule_HotwordRule::has_likelihood_adjustment() const {
  return this != internal_default_instance() && likelihood_adjustment_ != nullptr;
}
inline void CustomInfoType_DetectionRule_HotwordRule::clear_likelihood_adjustment() {
  if (GetArenaNoVirtual() == nullptr && likelihood_adjustment_ != nullptr) {
    delete likelihood_adjustment_;
  }
  likelihood_adjustment_ = nullptr;
}
inline const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment& CustomInfoType_DetectionRule_HotwordRule::likelihood_adjustment() const {
  const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* p = likelihood_adjustment_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.likelihood_adjustment)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment*>(
      &::google::privacy::dlp::v2::_CustomInfoType_DetectionRule_LikelihoodAdjustment_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* CustomInfoType_DetectionRule_HotwordRule::release_likelihood_adjustment() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.likelihood_adjustment)
  
  ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* temp = likelihood_adjustment_;
  likelihood_adjustment_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* CustomInfoType_DetectionRule_HotwordRule::mutable_likelihood_adjustment() {
  
  if (likelihood_adjustment_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment>(GetArenaNoVirtual());
    likelihood_adjustment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.likelihood_adjustment)
  return likelihood_adjustment_;
}
inline void CustomInfoType_DetectionRule_HotwordRule::set_allocated_likelihood_adjustment(::google::privacy::dlp::v2::CustomInfoType_DetectionRule_LikelihoodAdjustment* likelihood_adjustment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete likelihood_adjustment_;
  }
  if (likelihood_adjustment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      likelihood_adjustment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, likelihood_adjustment, submessage_arena);
    }
    
  } else {
    
  }
  likelihood_adjustment_ = likelihood_adjustment;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.likelihood_adjustment)
}

// -------------------------------------------------------------------

// CustomInfoType_DetectionRule

// .google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule hotword_rule = 1;
inline bool CustomInfoType_DetectionRule::has_hotword_rule() const {
  return type_case() == kHotwordRule;
}
inline void CustomInfoType_DetectionRule::set_has_hotword_rule() {
  _oneof_case_[0] = kHotwordRule;
}
inline void CustomInfoType_DetectionRule::clear_hotword_rule() {
  if (has_hotword_rule()) {
    delete type_.hotword_rule_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* CustomInfoType_DetectionRule::release_hotword_rule() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.DetectionRule.hotword_rule)
  if (has_hotword_rule()) {
    clear_has_type();
      ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* temp = type_.hotword_rule_;
    type_.hotword_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule& CustomInfoType_DetectionRule::hotword_rule() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.DetectionRule.hotword_rule)
  return has_hotword_rule()
      ? *type_.hotword_rule_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule*>(&::google::privacy::dlp::v2::_CustomInfoType_DetectionRule_HotwordRule_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule* CustomInfoType_DetectionRule::mutable_hotword_rule() {
  if (!has_hotword_rule()) {
    clear_type();
    set_has_hotword_rule();
    type_.hotword_rule_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule_HotwordRule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.DetectionRule.hotword_rule)
  return type_.hotword_rule_;
}

inline bool CustomInfoType_DetectionRule::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void CustomInfoType_DetectionRule::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline CustomInfoType_DetectionRule::TypeCase CustomInfoType_DetectionRule::type_case() const {
  return CustomInfoType_DetectionRule::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CustomInfoType

// .google.privacy.dlp.v2.InfoType info_type = 1;
inline bool CustomInfoType::has_info_type() const {
  return this != internal_default_instance() && info_type_ != nullptr;
}
inline void CustomInfoType::clear_info_type() {
  if (GetArenaNoVirtual() == nullptr && info_type_ != nullptr) {
    delete info_type_;
  }
  info_type_ = nullptr;
}
inline const ::google::privacy::dlp::v2::InfoType& CustomInfoType::info_type() const {
  const ::google::privacy::dlp::v2::InfoType* p = info_type_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.info_type)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::InfoType*>(
      &::google::privacy::dlp::v2::_InfoType_default_instance_);
}
inline ::google::privacy::dlp::v2::InfoType* CustomInfoType::release_info_type() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.info_type)
  
  ::google::privacy::dlp::v2::InfoType* temp = info_type_;
  info_type_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::InfoType* CustomInfoType::mutable_info_type() {
  
  if (info_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::InfoType>(GetArenaNoVirtual());
    info_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.info_type)
  return info_type_;
}
inline void CustomInfoType::set_allocated_info_type(::google::privacy::dlp::v2::InfoType* info_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_type_;
  }
  if (info_type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info_type, submessage_arena);
    }
    
  } else {
    
  }
  info_type_ = info_type;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CustomInfoType.info_type)
}

// .google.privacy.dlp.v2.Likelihood likelihood = 6;
inline void CustomInfoType::clear_likelihood() {
  likelihood_ = 0;
}
inline ::google::privacy::dlp::v2::Likelihood CustomInfoType::likelihood() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.likelihood)
  return static_cast< ::google::privacy::dlp::v2::Likelihood >(likelihood_);
}
inline void CustomInfoType::set_likelihood(::google::privacy::dlp::v2::Likelihood value) {
  
  likelihood_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.likelihood)
}

// .google.privacy.dlp.v2.CustomInfoType.Dictionary dictionary = 2;
inline bool CustomInfoType::has_dictionary() const {
  return type_case() == kDictionary;
}
inline void CustomInfoType::set_has_dictionary() {
  _oneof_case_[0] = kDictionary;
}
inline void CustomInfoType::clear_dictionary() {
  if (has_dictionary()) {
    delete type_.dictionary_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::CustomInfoType_Dictionary* CustomInfoType::release_dictionary() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.dictionary)
  if (has_dictionary()) {
    clear_has_type();
      ::google::privacy::dlp::v2::CustomInfoType_Dictionary* temp = type_.dictionary_;
    type_.dictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CustomInfoType_Dictionary& CustomInfoType::dictionary() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.dictionary)
  return has_dictionary()
      ? *type_.dictionary_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CustomInfoType_Dictionary*>(&::google::privacy::dlp::v2::_CustomInfoType_Dictionary_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_Dictionary* CustomInfoType::mutable_dictionary() {
  if (!has_dictionary()) {
    clear_type();
    set_has_dictionary();
    type_.dictionary_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CustomInfoType_Dictionary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.dictionary)
  return type_.dictionary_;
}

// .google.privacy.dlp.v2.CustomInfoType.Regex regex = 3;
inline bool CustomInfoType::has_regex() const {
  return type_case() == kRegex;
}
inline void CustomInfoType::set_has_regex() {
  _oneof_case_[0] = kRegex;
}
inline void CustomInfoType::clear_regex() {
  if (has_regex()) {
    delete type_.regex_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::CustomInfoType_Regex* CustomInfoType::release_regex() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.regex)
  if (has_regex()) {
    clear_has_type();
      ::google::privacy::dlp::v2::CustomInfoType_Regex* temp = type_.regex_;
    type_.regex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CustomInfoType_Regex& CustomInfoType::regex() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.regex)
  return has_regex()
      ? *type_.regex_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CustomInfoType_Regex*>(&::google::privacy::dlp::v2::_CustomInfoType_Regex_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_Regex* CustomInfoType::mutable_regex() {
  if (!has_regex()) {
    clear_type();
    set_has_regex();
    type_.regex_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CustomInfoType_Regex >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.regex)
  return type_.regex_;
}

// .google.privacy.dlp.v2.CustomInfoType.SurrogateType surrogate_type = 4;
inline bool CustomInfoType::has_surrogate_type() const {
  return type_case() == kSurrogateType;
}
inline void CustomInfoType::set_has_surrogate_type() {
  _oneof_case_[0] = kSurrogateType;
}
inline void CustomInfoType::clear_surrogate_type() {
  if (has_surrogate_type()) {
    delete type_.surrogate_type_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* CustomInfoType::release_surrogate_type() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.surrogate_type)
  if (has_surrogate_type()) {
    clear_has_type();
      ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* temp = type_.surrogate_type_;
    type_.surrogate_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CustomInfoType_SurrogateType& CustomInfoType::surrogate_type() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.surrogate_type)
  return has_surrogate_type()
      ? *type_.surrogate_type_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CustomInfoType_SurrogateType*>(&::google::privacy::dlp::v2::_CustomInfoType_SurrogateType_default_instance_);
}
inline ::google::privacy::dlp::v2::CustomInfoType_SurrogateType* CustomInfoType::mutable_surrogate_type() {
  if (!has_surrogate_type()) {
    clear_type();
    set_has_surrogate_type();
    type_.surrogate_type_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CustomInfoType_SurrogateType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.surrogate_type)
  return type_.surrogate_type_;
}

// .google.privacy.dlp.v2.StoredType stored_type = 5;
inline bool CustomInfoType::has_stored_type() const {
  return type_case() == kStoredType;
}
inline void CustomInfoType::set_has_stored_type() {
  _oneof_case_[0] = kStoredType;
}
inline void CustomInfoType::clear_stored_type() {
  if (has_stored_type()) {
    delete type_.stored_type_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::StoredType* CustomInfoType::release_stored_type() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CustomInfoType.stored_type)
  if (has_stored_type()) {
    clear_has_type();
      ::google::privacy::dlp::v2::StoredType* temp = type_.stored_type_;
    type_.stored_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::StoredType& CustomInfoType::stored_type() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.stored_type)
  return has_stored_type()
      ? *type_.stored_type_
      : *reinterpret_cast< ::google::privacy::dlp::v2::StoredType*>(&::google::privacy::dlp::v2::_StoredType_default_instance_);
}
inline ::google::privacy::dlp::v2::StoredType* CustomInfoType::mutable_stored_type() {
  if (!has_stored_type()) {
    clear_type();
    set_has_stored_type();
    type_.stored_type_ = CreateMaybeMessage< ::google::privacy::dlp::v2::StoredType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.stored_type)
  return type_.stored_type_;
}

// repeated .google.privacy.dlp.v2.CustomInfoType.DetectionRule detection_rules = 7;
inline int CustomInfoType::detection_rules_size() const {
  return detection_rules_.size();
}
inline void CustomInfoType::clear_detection_rules() {
  detection_rules_.Clear();
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule* CustomInfoType::mutable_detection_rules(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CustomInfoType.detection_rules)
  return detection_rules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule >*
CustomInfoType::mutable_detection_rules() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.CustomInfoType.detection_rules)
  return &detection_rules_;
}
inline const ::google::privacy::dlp::v2::CustomInfoType_DetectionRule& CustomInfoType::detection_rules(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.detection_rules)
  return detection_rules_.Get(index);
}
inline ::google::privacy::dlp::v2::CustomInfoType_DetectionRule* CustomInfoType::add_detection_rules() {
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CustomInfoType.detection_rules)
  return detection_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::CustomInfoType_DetectionRule >&
CustomInfoType::detection_rules() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.CustomInfoType.detection_rules)
  return detection_rules_;
}

// .google.privacy.dlp.v2.CustomInfoType.ExclusionType exclusion_type = 8;
inline void CustomInfoType::clear_exclusion_type() {
  exclusion_type_ = 0;
}
inline ::google::privacy::dlp::v2::CustomInfoType_ExclusionType CustomInfoType::exclusion_type() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CustomInfoType.exclusion_type)
  return static_cast< ::google::privacy::dlp::v2::CustomInfoType_ExclusionType >(exclusion_type_);
}
inline void CustomInfoType::set_exclusion_type(::google::privacy::dlp::v2::CustomInfoType_ExclusionType value) {
  
  exclusion_type_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CustomInfoType.exclusion_type)
}

inline bool CustomInfoType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void CustomInfoType::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline CustomInfoType::TypeCase CustomInfoType::type_case() const {
  return CustomInfoType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FieldId

// string name = 1;
inline void FieldId::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FieldId::name() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.FieldId.name)
  return name_.GetNoArena();
}
inline void FieldId::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.FieldId.name)
}
#if LANG_CXX11
inline void FieldId::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.FieldId.name)
}
#endif
inline void FieldId::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.FieldId.name)
}
inline void FieldId::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.FieldId.name)
}
inline ::std::string* FieldId::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.FieldId.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldId::release_name() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.FieldId.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldId::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.FieldId.name)
}

// -------------------------------------------------------------------

// PartitionId

// string project_id = 2;
inline void PartitionId::clear_project_id() {
  project_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionId::project_id() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.PartitionId.project_id)
  return project_id_.GetNoArena();
}
inline void PartitionId::set_project_id(const ::std::string& value) {
  
  project_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.PartitionId.project_id)
}
#if LANG_CXX11
inline void PartitionId::set_project_id(::std::string&& value) {
  
  project_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.PartitionId.project_id)
}
#endif
inline void PartitionId::set_project_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.PartitionId.project_id)
}
inline void PartitionId::set_project_id(const char* value, size_t size) {
  
  project_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.PartitionId.project_id)
}
inline ::std::string* PartitionId::mutable_project_id() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.PartitionId.project_id)
  return project_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionId::release_project_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.PartitionId.project_id)
  
  return project_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionId::set_allocated_project_id(::std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project_id);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.PartitionId.project_id)
}

// string namespace_id = 4;
inline void PartitionId::clear_namespace_id() {
  namespace_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionId::namespace_id() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.PartitionId.namespace_id)
  return namespace_id_.GetNoArena();
}
inline void PartitionId::set_namespace_id(const ::std::string& value) {
  
  namespace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.PartitionId.namespace_id)
}
#if LANG_CXX11
inline void PartitionId::set_namespace_id(::std::string&& value) {
  
  namespace_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.PartitionId.namespace_id)
}
#endif
inline void PartitionId::set_namespace_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  namespace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.PartitionId.namespace_id)
}
inline void PartitionId::set_namespace_id(const char* value, size_t size) {
  
  namespace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.PartitionId.namespace_id)
}
inline ::std::string* PartitionId::mutable_namespace_id() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.PartitionId.namespace_id)
  return namespace_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionId::release_namespace_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.PartitionId.namespace_id)
  
  return namespace_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionId::set_allocated_namespace_id(::std::string* namespace_id) {
  if (namespace_id != nullptr) {
    
  } else {
    
  }
  namespace_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_id);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.PartitionId.namespace_id)
}

// -------------------------------------------------------------------

// KindExpression

// string name = 1;
inline void KindExpression::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KindExpression::name() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.KindExpression.name)
  return name_.GetNoArena();
}
inline void KindExpression::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.KindExpression.name)
}
#if LANG_CXX11
inline void KindExpression::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.KindExpression.name)
}
#endif
inline void KindExpression::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.KindExpression.name)
}
inline void KindExpression::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.KindExpression.name)
}
inline ::std::string* KindExpression::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.KindExpression.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KindExpression::release_name() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.KindExpression.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KindExpression::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.KindExpression.name)
}

// -------------------------------------------------------------------

// DatastoreOptions

// .google.privacy.dlp.v2.PartitionId partition_id = 1;
inline bool DatastoreOptions::has_partition_id() const {
  return this != internal_default_instance() && partition_id_ != nullptr;
}
inline void DatastoreOptions::clear_partition_id() {
  if (GetArenaNoVirtual() == nullptr && partition_id_ != nullptr) {
    delete partition_id_;
  }
  partition_id_ = nullptr;
}
inline const ::google::privacy::dlp::v2::PartitionId& DatastoreOptions::partition_id() const {
  const ::google::privacy::dlp::v2::PartitionId* p = partition_id_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.DatastoreOptions.partition_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::PartitionId*>(
      &::google::privacy::dlp::v2::_PartitionId_default_instance_);
}
inline ::google::privacy::dlp::v2::PartitionId* DatastoreOptions::release_partition_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.DatastoreOptions.partition_id)
  
  ::google::privacy::dlp::v2::PartitionId* temp = partition_id_;
  partition_id_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::PartitionId* DatastoreOptions::mutable_partition_id() {
  
  if (partition_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::PartitionId>(GetArenaNoVirtual());
    partition_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.DatastoreOptions.partition_id)
  return partition_id_;
}
inline void DatastoreOptions::set_allocated_partition_id(::google::privacy::dlp::v2::PartitionId* partition_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete partition_id_;
  }
  if (partition_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      partition_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, partition_id, submessage_arena);
    }
    
  } else {
    
  }
  partition_id_ = partition_id;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.DatastoreOptions.partition_id)
}

// .google.privacy.dlp.v2.KindExpression kind = 2;
inline bool DatastoreOptions::has_kind() const {
  return this != internal_default_instance() && kind_ != nullptr;
}
inline void DatastoreOptions::clear_kind() {
  if (GetArenaNoVirtual() == nullptr && kind_ != nullptr) {
    delete kind_;
  }
  kind_ = nullptr;
}
inline const ::google::privacy::dlp::v2::KindExpression& DatastoreOptions::kind() const {
  const ::google::privacy::dlp::v2::KindExpression* p = kind_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.DatastoreOptions.kind)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::KindExpression*>(
      &::google::privacy::dlp::v2::_KindExpression_default_instance_);
}
inline ::google::privacy::dlp::v2::KindExpression* DatastoreOptions::release_kind() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.DatastoreOptions.kind)
  
  ::google::privacy::dlp::v2::KindExpression* temp = kind_;
  kind_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::KindExpression* DatastoreOptions::mutable_kind() {
  
  if (kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::KindExpression>(GetArenaNoVirtual());
    kind_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.DatastoreOptions.kind)
  return kind_;
}
inline void DatastoreOptions::set_allocated_kind(::google::privacy::dlp::v2::KindExpression* kind) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kind_;
  }
  if (kind) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kind = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kind, submessage_arena);
    }
    
  } else {
    
  }
  kind_ = kind;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.DatastoreOptions.kind)
}

// -------------------------------------------------------------------

// CloudStorageRegexFileSet

// string bucket_name = 1;
inline void CloudStorageRegexFileSet::clear_bucket_name() {
  bucket_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudStorageRegexFileSet::bucket_name() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
  return bucket_name_.GetNoArena();
}
inline void CloudStorageRegexFileSet::set_bucket_name(const ::std::string& value) {
  
  bucket_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
}
#if LANG_CXX11
inline void CloudStorageRegexFileSet::set_bucket_name(::std::string&& value) {
  
  bucket_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
}
#endif
inline void CloudStorageRegexFileSet::set_bucket_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bucket_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
}
inline void CloudStorageRegexFileSet::set_bucket_name(const char* value, size_t size) {
  
  bucket_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
}
inline ::std::string* CloudStorageRegexFileSet::mutable_bucket_name() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
  return bucket_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudStorageRegexFileSet::release_bucket_name() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
  
  return bucket_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudStorageRegexFileSet::set_allocated_bucket_name(::std::string* bucket_name) {
  if (bucket_name != nullptr) {
    
  } else {
    
  }
  bucket_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket_name);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CloudStorageRegexFileSet.bucket_name)
}

// repeated string include_regex = 2;
inline int CloudStorageRegexFileSet::include_regex_size() const {
  return include_regex_.size();
}
inline void CloudStorageRegexFileSet::clear_include_regex() {
  include_regex_.Clear();
}
inline const ::std::string& CloudStorageRegexFileSet::include_regex(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  return include_regex_.Get(index);
}
inline ::std::string* CloudStorageRegexFileSet::mutable_include_regex(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  return include_regex_.Mutable(index);
}
inline void CloudStorageRegexFileSet::set_include_regex(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  include_regex_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CloudStorageRegexFileSet::set_include_regex(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  include_regex_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CloudStorageRegexFileSet::set_include_regex(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  include_regex_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
}
inline void CloudStorageRegexFileSet::set_include_regex(int index, const char* value, size_t size) {
  include_regex_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
}
inline ::std::string* CloudStorageRegexFileSet::add_include_regex() {
  // @@protoc_insertion_point(field_add_mutable:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  return include_regex_.Add();
}
inline void CloudStorageRegexFileSet::add_include_regex(const ::std::string& value) {
  include_regex_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
}
#if LANG_CXX11
inline void CloudStorageRegexFileSet::add_include_regex(::std::string&& value) {
  include_regex_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
}
#endif
inline void CloudStorageRegexFileSet::add_include_regex(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  include_regex_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
}
inline void CloudStorageRegexFileSet::add_include_regex(const char* value, size_t size) {
  include_regex_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CloudStorageRegexFileSet::include_regex() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  return include_regex_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
CloudStorageRegexFileSet::mutable_include_regex() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.CloudStorageRegexFileSet.include_regex)
  return &include_regex_;
}

// repeated string exclude_regex = 3;
inline int CloudStorageRegexFileSet::exclude_regex_size() const {
  return exclude_regex_.size();
}
inline void CloudStorageRegexFileSet::clear_exclude_regex() {
  exclude_regex_.Clear();
}
inline const ::std::string& CloudStorageRegexFileSet::exclude_regex(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  return exclude_regex_.Get(index);
}
inline ::std::string* CloudStorageRegexFileSet::mutable_exclude_regex(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  return exclude_regex_.Mutable(index);
}
inline void CloudStorageRegexFileSet::set_exclude_regex(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  exclude_regex_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CloudStorageRegexFileSet::set_exclude_regex(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  exclude_regex_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CloudStorageRegexFileSet::set_exclude_regex(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exclude_regex_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
}
inline void CloudStorageRegexFileSet::set_exclude_regex(int index, const char* value, size_t size) {
  exclude_regex_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
}
inline ::std::string* CloudStorageRegexFileSet::add_exclude_regex() {
  // @@protoc_insertion_point(field_add_mutable:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  return exclude_regex_.Add();
}
inline void CloudStorageRegexFileSet::add_exclude_regex(const ::std::string& value) {
  exclude_regex_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
}
#if LANG_CXX11
inline void CloudStorageRegexFileSet::add_exclude_regex(::std::string&& value) {
  exclude_regex_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
}
#endif
inline void CloudStorageRegexFileSet::add_exclude_regex(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exclude_regex_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
}
inline void CloudStorageRegexFileSet::add_exclude_regex(const char* value, size_t size) {
  exclude_regex_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CloudStorageRegexFileSet::exclude_regex() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  return exclude_regex_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
CloudStorageRegexFileSet::mutable_exclude_regex() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.CloudStorageRegexFileSet.exclude_regex)
  return &exclude_regex_;
}

// -------------------------------------------------------------------

// CloudStorageOptions_FileSet

// string url = 1;
inline void CloudStorageOptions_FileSet::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudStorageOptions_FileSet::url() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
  return url_.GetNoArena();
}
inline void CloudStorageOptions_FileSet::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
}
#if LANG_CXX11
inline void CloudStorageOptions_FileSet::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
}
#endif
inline void CloudStorageOptions_FileSet::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
}
inline void CloudStorageOptions_FileSet::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
}
inline ::std::string* CloudStorageOptions_FileSet::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudStorageOptions_FileSet::release_url() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudStorageOptions_FileSet::set_allocated_url(::std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CloudStorageOptions.FileSet.url)
}

// .google.privacy.dlp.v2.CloudStorageRegexFileSet regex_file_set = 2;
inline bool CloudStorageOptions_FileSet::has_regex_file_set() const {
  return this != internal_default_instance() && regex_file_set_ != nullptr;
}
inline void CloudStorageOptions_FileSet::clear_regex_file_set() {
  if (GetArenaNoVirtual() == nullptr && regex_file_set_ != nullptr) {
    delete regex_file_set_;
  }
  regex_file_set_ = nullptr;
}
inline const ::google::privacy::dlp::v2::CloudStorageRegexFileSet& CloudStorageOptions_FileSet::regex_file_set() const {
  const ::google::privacy::dlp::v2::CloudStorageRegexFileSet* p = regex_file_set_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.FileSet.regex_file_set)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::CloudStorageRegexFileSet*>(
      &::google::privacy::dlp::v2::_CloudStorageRegexFileSet_default_instance_);
}
inline ::google::privacy::dlp::v2::CloudStorageRegexFileSet* CloudStorageOptions_FileSet::release_regex_file_set() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CloudStorageOptions.FileSet.regex_file_set)
  
  ::google::privacy::dlp::v2::CloudStorageRegexFileSet* temp = regex_file_set_;
  regex_file_set_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::CloudStorageRegexFileSet* CloudStorageOptions_FileSet::mutable_regex_file_set() {
  
  if (regex_file_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::CloudStorageRegexFileSet>(GetArenaNoVirtual());
    regex_file_set_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageOptions.FileSet.regex_file_set)
  return regex_file_set_;
}
inline void CloudStorageOptions_FileSet::set_allocated_regex_file_set(::google::privacy::dlp::v2::CloudStorageRegexFileSet* regex_file_set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regex_file_set_;
  }
  if (regex_file_set) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regex_file_set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regex_file_set, submessage_arena);
    }
    
  } else {
    
  }
  regex_file_set_ = regex_file_set;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CloudStorageOptions.FileSet.regex_file_set)
}

// -------------------------------------------------------------------

// CloudStorageOptions

// .google.privacy.dlp.v2.CloudStorageOptions.FileSet file_set = 1;
inline bool CloudStorageOptions::has_file_set() const {
  return this != internal_default_instance() && file_set_ != nullptr;
}
inline void CloudStorageOptions::clear_file_set() {
  if (GetArenaNoVirtual() == nullptr && file_set_ != nullptr) {
    delete file_set_;
  }
  file_set_ = nullptr;
}
inline const ::google::privacy::dlp::v2::CloudStorageOptions_FileSet& CloudStorageOptions::file_set() const {
  const ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* p = file_set_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.file_set)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::CloudStorageOptions_FileSet*>(
      &::google::privacy::dlp::v2::_CloudStorageOptions_FileSet_default_instance_);
}
inline ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* CloudStorageOptions::release_file_set() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CloudStorageOptions.file_set)
  
  ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* temp = file_set_;
  file_set_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::CloudStorageOptions_FileSet* CloudStorageOptions::mutable_file_set() {
  
  if (file_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::CloudStorageOptions_FileSet>(GetArenaNoVirtual());
    file_set_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageOptions.file_set)
  return file_set_;
}
inline void CloudStorageOptions::set_allocated_file_set(::google::privacy::dlp::v2::CloudStorageOptions_FileSet* file_set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete file_set_;
  }
  if (file_set) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      file_set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file_set, submessage_arena);
    }
    
  } else {
    
  }
  file_set_ = file_set;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CloudStorageOptions.file_set)
}

// int64 bytes_limit_per_file = 4;
inline void CloudStorageOptions::clear_bytes_limit_per_file() {
  bytes_limit_per_file_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 CloudStorageOptions::bytes_limit_per_file() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file)
  return bytes_limit_per_file_;
}
inline void CloudStorageOptions::set_bytes_limit_per_file(::google::protobuf::int64 value) {
  
  bytes_limit_per_file_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file)
}

// int32 bytes_limit_per_file_percent = 8;
inline void CloudStorageOptions::clear_bytes_limit_per_file_percent() {
  bytes_limit_per_file_percent_ = 0;
}
inline ::google::protobuf::int32 CloudStorageOptions::bytes_limit_per_file_percent() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file_percent)
  return bytes_limit_per_file_percent_;
}
inline void CloudStorageOptions::set_bytes_limit_per_file_percent(::google::protobuf::int32 value) {
  
  bytes_limit_per_file_percent_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file_percent)
}

// repeated .google.privacy.dlp.v2.FileType file_types = 5;
inline int CloudStorageOptions::file_types_size() const {
  return file_types_.size();
}
inline void CloudStorageOptions::clear_file_types() {
  file_types_.Clear();
}
inline ::google::privacy::dlp::v2::FileType CloudStorageOptions::file_types(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.file_types)
  return static_cast< ::google::privacy::dlp::v2::FileType >(file_types_.Get(index));
}
inline void CloudStorageOptions::set_file_types(int index, ::google::privacy::dlp::v2::FileType value) {
  file_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageOptions.file_types)
}
inline void CloudStorageOptions::add_file_types(::google::privacy::dlp::v2::FileType value) {
  file_types_.Add(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.CloudStorageOptions.file_types)
}
inline const ::google::protobuf::RepeatedField<int>&
CloudStorageOptions::file_types() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.CloudStorageOptions.file_types)
  return file_types_;
}
inline ::google::protobuf::RepeatedField<int>*
CloudStorageOptions::mutable_file_types() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.CloudStorageOptions.file_types)
  return &file_types_;
}

// .google.privacy.dlp.v2.CloudStorageOptions.SampleMethod sample_method = 6;
inline void CloudStorageOptions::clear_sample_method() {
  sample_method_ = 0;
}
inline ::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod CloudStorageOptions::sample_method() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.sample_method)
  return static_cast< ::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod >(sample_method_);
}
inline void CloudStorageOptions::set_sample_method(::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod value) {
  
  sample_method_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageOptions.sample_method)
}

// int32 files_limit_percent = 7;
inline void CloudStorageOptions::clear_files_limit_percent() {
  files_limit_percent_ = 0;
}
inline ::google::protobuf::int32 CloudStorageOptions::files_limit_percent() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageOptions.files_limit_percent)
  return files_limit_percent_;
}
inline void CloudStorageOptions::set_files_limit_percent(::google::protobuf::int32 value) {
  
  files_limit_percent_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageOptions.files_limit_percent)
}

// -------------------------------------------------------------------

// CloudStorageFileSet

// string url = 1;
inline void CloudStorageFileSet::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudStorageFileSet::url() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStorageFileSet.url)
  return url_.GetNoArena();
}
inline void CloudStorageFileSet::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStorageFileSet.url)
}
#if LANG_CXX11
inline void CloudStorageFileSet::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.CloudStorageFileSet.url)
}
#endif
inline void CloudStorageFileSet::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CloudStorageFileSet.url)
}
inline void CloudStorageFileSet::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CloudStorageFileSet.url)
}
inline ::std::string* CloudStorageFileSet::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStorageFileSet.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudStorageFileSet::release_url() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CloudStorageFileSet.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudStorageFileSet::set_allocated_url(::std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CloudStorageFileSet.url)
}

// -------------------------------------------------------------------

// CloudStoragePath

// string path = 1;
inline void CloudStoragePath::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloudStoragePath::path() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.CloudStoragePath.path)
  return path_.GetNoArena();
}
inline void CloudStoragePath::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.CloudStoragePath.path)
}
#if LANG_CXX11
inline void CloudStoragePath::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.CloudStoragePath.path)
}
#endif
inline void CloudStoragePath::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.CloudStoragePath.path)
}
inline void CloudStoragePath::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.CloudStoragePath.path)
}
inline ::std::string* CloudStoragePath::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.CloudStoragePath.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloudStoragePath::release_path() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.CloudStoragePath.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloudStoragePath::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.CloudStoragePath.path)
}

// -------------------------------------------------------------------

// BigQueryOptions

// .google.privacy.dlp.v2.BigQueryTable table_reference = 1;
inline bool BigQueryOptions::has_table_reference() const {
  return this != internal_default_instance() && table_reference_ != nullptr;
}
inline void BigQueryOptions::clear_table_reference() {
  if (GetArenaNoVirtual() == nullptr && table_reference_ != nullptr) {
    delete table_reference_;
  }
  table_reference_ = nullptr;
}
inline const ::google::privacy::dlp::v2::BigQueryTable& BigQueryOptions::table_reference() const {
  const ::google::privacy::dlp::v2::BigQueryTable* p = table_reference_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryOptions.table_reference)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::BigQueryTable*>(
      &::google::privacy::dlp::v2::_BigQueryTable_default_instance_);
}
inline ::google::privacy::dlp::v2::BigQueryTable* BigQueryOptions::release_table_reference() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryOptions.table_reference)
  
  ::google::privacy::dlp::v2::BigQueryTable* temp = table_reference_;
  table_reference_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::BigQueryTable* BigQueryOptions::mutable_table_reference() {
  
  if (table_reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryTable>(GetArenaNoVirtual());
    table_reference_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryOptions.table_reference)
  return table_reference_;
}
inline void BigQueryOptions::set_allocated_table_reference(::google::privacy::dlp::v2::BigQueryTable* table_reference) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_reference_;
  }
  if (table_reference) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_reference = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_reference, submessage_arena);
    }
    
  } else {
    
  }
  table_reference_ = table_reference;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryOptions.table_reference)
}

// repeated .google.privacy.dlp.v2.FieldId identifying_fields = 2;
inline int BigQueryOptions::identifying_fields_size() const {
  return identifying_fields_.size();
}
inline void BigQueryOptions::clear_identifying_fields() {
  identifying_fields_.Clear();
}
inline ::google::privacy::dlp::v2::FieldId* BigQueryOptions::mutable_identifying_fields(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryOptions.identifying_fields)
  return identifying_fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >*
BigQueryOptions::mutable_identifying_fields() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.BigQueryOptions.identifying_fields)
  return &identifying_fields_;
}
inline const ::google::privacy::dlp::v2::FieldId& BigQueryOptions::identifying_fields(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryOptions.identifying_fields)
  return identifying_fields_.Get(index);
}
inline ::google::privacy::dlp::v2::FieldId* BigQueryOptions::add_identifying_fields() {
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.BigQueryOptions.identifying_fields)
  return identifying_fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >&
BigQueryOptions::identifying_fields() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.BigQueryOptions.identifying_fields)
  return identifying_fields_;
}

// int64 rows_limit = 3;
inline void BigQueryOptions::clear_rows_limit() {
  rows_limit_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BigQueryOptions::rows_limit() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryOptions.rows_limit)
  return rows_limit_;
}
inline void BigQueryOptions::set_rows_limit(::google::protobuf::int64 value) {
  
  rows_limit_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryOptions.rows_limit)
}

// int32 rows_limit_percent = 6;
inline void BigQueryOptions::clear_rows_limit_percent() {
  rows_limit_percent_ = 0;
}
inline ::google::protobuf::int32 BigQueryOptions::rows_limit_percent() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryOptions.rows_limit_percent)
  return rows_limit_percent_;
}
inline void BigQueryOptions::set_rows_limit_percent(::google::protobuf::int32 value) {
  
  rows_limit_percent_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryOptions.rows_limit_percent)
}

// .google.privacy.dlp.v2.BigQueryOptions.SampleMethod sample_method = 4;
inline void BigQueryOptions::clear_sample_method() {
  sample_method_ = 0;
}
inline ::google::privacy::dlp::v2::BigQueryOptions_SampleMethod BigQueryOptions::sample_method() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryOptions.sample_method)
  return static_cast< ::google::privacy::dlp::v2::BigQueryOptions_SampleMethod >(sample_method_);
}
inline void BigQueryOptions::set_sample_method(::google::privacy::dlp::v2::BigQueryOptions_SampleMethod value) {
  
  sample_method_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryOptions.sample_method)
}

// repeated .google.privacy.dlp.v2.FieldId excluded_fields = 5;
inline int BigQueryOptions::excluded_fields_size() const {
  return excluded_fields_.size();
}
inline void BigQueryOptions::clear_excluded_fields() {
  excluded_fields_.Clear();
}
inline ::google::privacy::dlp::v2::FieldId* BigQueryOptions::mutable_excluded_fields(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryOptions.excluded_fields)
  return excluded_fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >*
BigQueryOptions::mutable_excluded_fields() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.BigQueryOptions.excluded_fields)
  return &excluded_fields_;
}
inline const ::google::privacy::dlp::v2::FieldId& BigQueryOptions::excluded_fields(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryOptions.excluded_fields)
  return excluded_fields_.Get(index);
}
inline ::google::privacy::dlp::v2::FieldId* BigQueryOptions::add_excluded_fields() {
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.BigQueryOptions.excluded_fields)
  return excluded_fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >&
BigQueryOptions::excluded_fields() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.BigQueryOptions.excluded_fields)
  return excluded_fields_;
}

// -------------------------------------------------------------------

// StorageConfig_TimespanConfig

// .google.protobuf.Timestamp start_time = 1;
inline bool StorageConfig_TimespanConfig::has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline const ::google::protobuf::Timestamp& StorageConfig_TimespanConfig::start_time() const {
  const ::google::protobuf::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.TimespanConfig.start_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* StorageConfig_TimespanConfig::release_start_time() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.TimespanConfig.start_time)
  
  ::google::protobuf::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* StorageConfig_TimespanConfig::mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.TimespanConfig.start_time)
  return start_time_;
}
inline void StorageConfig_TimespanConfig::set_allocated_start_time(::google::protobuf::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.StorageConfig.TimespanConfig.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool StorageConfig_TimespanConfig::has_end_time() const {
  return this != internal_default_instance() && end_time_ != nullptr;
}
inline const ::google::protobuf::Timestamp& StorageConfig_TimespanConfig::end_time() const {
  const ::google::protobuf::Timestamp* p = end_time_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.TimespanConfig.end_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* StorageConfig_TimespanConfig::release_end_time() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.TimespanConfig.end_time)
  
  ::google::protobuf::Timestamp* temp = end_time_;
  end_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* StorageConfig_TimespanConfig::mutable_end_time() {
  
  if (end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    end_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.TimespanConfig.end_time)
  return end_time_;
}
inline void StorageConfig_TimespanConfig::set_allocated_end_time(::google::protobuf::Timestamp* end_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(end_time)->GetArena();
    if (message_arena != submessage_arena) {
      end_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.StorageConfig.TimespanConfig.end_time)
}

// .google.privacy.dlp.v2.FieldId timestamp_field = 3;
inline bool StorageConfig_TimespanConfig::has_timestamp_field() const {
  return this != internal_default_instance() && timestamp_field_ != nullptr;
}
inline void StorageConfig_TimespanConfig::clear_timestamp_field() {
  if (GetArenaNoVirtual() == nullptr && timestamp_field_ != nullptr) {
    delete timestamp_field_;
  }
  timestamp_field_ = nullptr;
}
inline const ::google::privacy::dlp::v2::FieldId& StorageConfig_TimespanConfig::timestamp_field() const {
  const ::google::privacy::dlp::v2::FieldId* p = timestamp_field_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.TimespanConfig.timestamp_field)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::FieldId*>(
      &::google::privacy::dlp::v2::_FieldId_default_instance_);
}
inline ::google::privacy::dlp::v2::FieldId* StorageConfig_TimespanConfig::release_timestamp_field() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.TimespanConfig.timestamp_field)
  
  ::google::privacy::dlp::v2::FieldId* temp = timestamp_field_;
  timestamp_field_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::FieldId* StorageConfig_TimespanConfig::mutable_timestamp_field() {
  
  if (timestamp_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::FieldId>(GetArenaNoVirtual());
    timestamp_field_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.TimespanConfig.timestamp_field)
  return timestamp_field_;
}
inline void StorageConfig_TimespanConfig::set_allocated_timestamp_field(::google::privacy::dlp::v2::FieldId* timestamp_field) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timestamp_field_;
  }
  if (timestamp_field) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timestamp_field = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp_field, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_field_ = timestamp_field;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.StorageConfig.TimespanConfig.timestamp_field)
}

// bool enable_auto_population_of_timespan_config = 4;
inline void StorageConfig_TimespanConfig::clear_enable_auto_population_of_timespan_config() {
  enable_auto_population_of_timespan_config_ = false;
}
inline bool StorageConfig_TimespanConfig::enable_auto_population_of_timespan_config() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.TimespanConfig.enable_auto_population_of_timespan_config)
  return enable_auto_population_of_timespan_config_;
}
inline void StorageConfig_TimespanConfig::set_enable_auto_population_of_timespan_config(bool value) {
  
  enable_auto_population_of_timespan_config_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.StorageConfig.TimespanConfig.enable_auto_population_of_timespan_config)
}

// -------------------------------------------------------------------

// StorageConfig

// .google.privacy.dlp.v2.DatastoreOptions datastore_options = 2;
inline bool StorageConfig::has_datastore_options() const {
  return type_case() == kDatastoreOptions;
}
inline void StorageConfig::set_has_datastore_options() {
  _oneof_case_[0] = kDatastoreOptions;
}
inline void StorageConfig::clear_datastore_options() {
  if (has_datastore_options()) {
    delete type_.datastore_options_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::DatastoreOptions* StorageConfig::release_datastore_options() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.datastore_options)
  if (has_datastore_options()) {
    clear_has_type();
      ::google::privacy::dlp::v2::DatastoreOptions* temp = type_.datastore_options_;
    type_.datastore_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::DatastoreOptions& StorageConfig::datastore_options() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.datastore_options)
  return has_datastore_options()
      ? *type_.datastore_options_
      : *reinterpret_cast< ::google::privacy::dlp::v2::DatastoreOptions*>(&::google::privacy::dlp::v2::_DatastoreOptions_default_instance_);
}
inline ::google::privacy::dlp::v2::DatastoreOptions* StorageConfig::mutable_datastore_options() {
  if (!has_datastore_options()) {
    clear_type();
    set_has_datastore_options();
    type_.datastore_options_ = CreateMaybeMessage< ::google::privacy::dlp::v2::DatastoreOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.datastore_options)
  return type_.datastore_options_;
}

// .google.privacy.dlp.v2.CloudStorageOptions cloud_storage_options = 3;
inline bool StorageConfig::has_cloud_storage_options() const {
  return type_case() == kCloudStorageOptions;
}
inline void StorageConfig::set_has_cloud_storage_options() {
  _oneof_case_[0] = kCloudStorageOptions;
}
inline void StorageConfig::clear_cloud_storage_options() {
  if (has_cloud_storage_options()) {
    delete type_.cloud_storage_options_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::CloudStorageOptions* StorageConfig::release_cloud_storage_options() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.cloud_storage_options)
  if (has_cloud_storage_options()) {
    clear_has_type();
      ::google::privacy::dlp::v2::CloudStorageOptions* temp = type_.cloud_storage_options_;
    type_.cloud_storage_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::CloudStorageOptions& StorageConfig::cloud_storage_options() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.cloud_storage_options)
  return has_cloud_storage_options()
      ? *type_.cloud_storage_options_
      : *reinterpret_cast< ::google::privacy::dlp::v2::CloudStorageOptions*>(&::google::privacy::dlp::v2::_CloudStorageOptions_default_instance_);
}
inline ::google::privacy::dlp::v2::CloudStorageOptions* StorageConfig::mutable_cloud_storage_options() {
  if (!has_cloud_storage_options()) {
    clear_type();
    set_has_cloud_storage_options();
    type_.cloud_storage_options_ = CreateMaybeMessage< ::google::privacy::dlp::v2::CloudStorageOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.cloud_storage_options)
  return type_.cloud_storage_options_;
}

// .google.privacy.dlp.v2.BigQueryOptions big_query_options = 4;
inline bool StorageConfig::has_big_query_options() const {
  return type_case() == kBigQueryOptions;
}
inline void StorageConfig::set_has_big_query_options() {
  _oneof_case_[0] = kBigQueryOptions;
}
inline void StorageConfig::clear_big_query_options() {
  if (has_big_query_options()) {
    delete type_.big_query_options_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::BigQueryOptions* StorageConfig::release_big_query_options() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.big_query_options)
  if (has_big_query_options()) {
    clear_has_type();
      ::google::privacy::dlp::v2::BigQueryOptions* temp = type_.big_query_options_;
    type_.big_query_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::BigQueryOptions& StorageConfig::big_query_options() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.big_query_options)
  return has_big_query_options()
      ? *type_.big_query_options_
      : *reinterpret_cast< ::google::privacy::dlp::v2::BigQueryOptions*>(&::google::privacy::dlp::v2::_BigQueryOptions_default_instance_);
}
inline ::google::privacy::dlp::v2::BigQueryOptions* StorageConfig::mutable_big_query_options() {
  if (!has_big_query_options()) {
    clear_type();
    set_has_big_query_options();
    type_.big_query_options_ = CreateMaybeMessage< ::google::privacy::dlp::v2::BigQueryOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.big_query_options)
  return type_.big_query_options_;
}

// .google.privacy.dlp.v2.HybridOptions hybrid_options = 9;
inline bool StorageConfig::has_hybrid_options() const {
  return type_case() == kHybridOptions;
}
inline void StorageConfig::set_has_hybrid_options() {
  _oneof_case_[0] = kHybridOptions;
}
inline void StorageConfig::clear_hybrid_options() {
  if (has_hybrid_options()) {
    delete type_.hybrid_options_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::HybridOptions* StorageConfig::release_hybrid_options() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.hybrid_options)
  if (has_hybrid_options()) {
    clear_has_type();
      ::google::privacy::dlp::v2::HybridOptions* temp = type_.hybrid_options_;
    type_.hybrid_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::HybridOptions& StorageConfig::hybrid_options() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.hybrid_options)
  return has_hybrid_options()
      ? *type_.hybrid_options_
      : *reinterpret_cast< ::google::privacy::dlp::v2::HybridOptions*>(&::google::privacy::dlp::v2::_HybridOptions_default_instance_);
}
inline ::google::privacy::dlp::v2::HybridOptions* StorageConfig::mutable_hybrid_options() {
  if (!has_hybrid_options()) {
    clear_type();
    set_has_hybrid_options();
    type_.hybrid_options_ = CreateMaybeMessage< ::google::privacy::dlp::v2::HybridOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.hybrid_options)
  return type_.hybrid_options_;
}

// .google.privacy.dlp.v2.StorageConfig.TimespanConfig timespan_config = 6;
inline bool StorageConfig::has_timespan_config() const {
  return this != internal_default_instance() && timespan_config_ != nullptr;
}
inline void StorageConfig::clear_timespan_config() {
  if (GetArenaNoVirtual() == nullptr && timespan_config_ != nullptr) {
    delete timespan_config_;
  }
  timespan_config_ = nullptr;
}
inline const ::google::privacy::dlp::v2::StorageConfig_TimespanConfig& StorageConfig::timespan_config() const {
  const ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* p = timespan_config_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.StorageConfig.timespan_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::StorageConfig_TimespanConfig*>(
      &::google::privacy::dlp::v2::_StorageConfig_TimespanConfig_default_instance_);
}
inline ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* StorageConfig::release_timespan_config() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.StorageConfig.timespan_config)
  
  ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* temp = timespan_config_;
  timespan_config_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::StorageConfig_TimespanConfig* StorageConfig::mutable_timespan_config() {
  
  if (timespan_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::StorageConfig_TimespanConfig>(GetArenaNoVirtual());
    timespan_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.StorageConfig.timespan_config)
  return timespan_config_;
}
inline void StorageConfig::set_allocated_timespan_config(::google::privacy::dlp::v2::StorageConfig_TimespanConfig* timespan_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timespan_config_;
  }
  if (timespan_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timespan_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timespan_config, submessage_arena);
    }
    
  } else {
    
  }
  timespan_config_ = timespan_config;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.StorageConfig.timespan_config)
}

inline bool StorageConfig::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void StorageConfig::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline StorageConfig::TypeCase StorageConfig::type_case() const {
  return StorageConfig::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HybridOptions

// string description = 1;
inline void HybridOptions::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HybridOptions::description() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.HybridOptions.description)
  return description_.GetNoArena();
}
inline void HybridOptions::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.HybridOptions.description)
}
#if LANG_CXX11
inline void HybridOptions::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.HybridOptions.description)
}
#endif
inline void HybridOptions::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.HybridOptions.description)
}
inline void HybridOptions::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.HybridOptions.description)
}
inline ::std::string* HybridOptions::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.HybridOptions.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HybridOptions::release_description() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.HybridOptions.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HybridOptions::set_allocated_description(::std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.HybridOptions.description)
}

// repeated string required_finding_label_keys = 2;
inline int HybridOptions::required_finding_label_keys_size() const {
  return required_finding_label_keys_.size();
}
inline void HybridOptions::clear_required_finding_label_keys() {
  required_finding_label_keys_.Clear();
}
inline const ::std::string& HybridOptions::required_finding_label_keys(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  return required_finding_label_keys_.Get(index);
}
inline ::std::string* HybridOptions::mutable_required_finding_label_keys(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  return required_finding_label_keys_.Mutable(index);
}
inline void HybridOptions::set_required_finding_label_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  required_finding_label_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HybridOptions::set_required_finding_label_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  required_finding_label_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HybridOptions::set_required_finding_label_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_finding_label_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
}
inline void HybridOptions::set_required_finding_label_keys(int index, const char* value, size_t size) {
  required_finding_label_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
}
inline ::std::string* HybridOptions::add_required_finding_label_keys() {
  // @@protoc_insertion_point(field_add_mutable:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  return required_finding_label_keys_.Add();
}
inline void HybridOptions::add_required_finding_label_keys(const ::std::string& value) {
  required_finding_label_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
}
#if LANG_CXX11
inline void HybridOptions::add_required_finding_label_keys(::std::string&& value) {
  required_finding_label_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
}
#endif
inline void HybridOptions::add_required_finding_label_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_finding_label_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
}
inline void HybridOptions::add_required_finding_label_keys(const char* value, size_t size) {
  required_finding_label_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
HybridOptions::required_finding_label_keys() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  return required_finding_label_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
HybridOptions::mutable_required_finding_label_keys() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.HybridOptions.required_finding_label_keys)
  return &required_finding_label_keys_;
}

// map<string, string> labels = 3;
inline int HybridOptions::labels_size() const {
  return labels_.size();
}
inline void HybridOptions::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HybridOptions::labels() const {
  // @@protoc_insertion_point(field_map:google.privacy.dlp.v2.HybridOptions.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HybridOptions::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.privacy.dlp.v2.HybridOptions.labels)
  return labels_.MutableMap();
}

// .google.privacy.dlp.v2.TableOptions table_options = 4;
inline bool HybridOptions::has_table_options() const {
  return this != internal_default_instance() && table_options_ != nullptr;
}
inline void HybridOptions::clear_table_options() {
  if (GetArenaNoVirtual() == nullptr && table_options_ != nullptr) {
    delete table_options_;
  }
  table_options_ = nullptr;
}
inline const ::google::privacy::dlp::v2::TableOptions& HybridOptions::table_options() const {
  const ::google::privacy::dlp::v2::TableOptions* p = table_options_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.HybridOptions.table_options)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::TableOptions*>(
      &::google::privacy::dlp::v2::_TableOptions_default_instance_);
}
inline ::google::privacy::dlp::v2::TableOptions* HybridOptions::release_table_options() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.HybridOptions.table_options)
  
  ::google::privacy::dlp::v2::TableOptions* temp = table_options_;
  table_options_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::TableOptions* HybridOptions::mutable_table_options() {
  
  if (table_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::TableOptions>(GetArenaNoVirtual());
    table_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.HybridOptions.table_options)
  return table_options_;
}
inline void HybridOptions::set_allocated_table_options(::google::privacy::dlp::v2::TableOptions* table_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_options_;
  }
  if (table_options) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_options, submessage_arena);
    }
    
  } else {
    
  }
  table_options_ = table_options;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.HybridOptions.table_options)
}

// -------------------------------------------------------------------

// BigQueryKey

// .google.privacy.dlp.v2.BigQueryTable table_reference = 1;
inline bool BigQueryKey::has_table_reference() const {
  return this != internal_default_instance() && table_reference_ != nullptr;
}
inline void BigQueryKey::clear_table_reference() {
  if (GetArenaNoVirtual() == nullptr && table_reference_ != nullptr) {
    delete table_reference_;
  }
  table_reference_ = nullptr;
}
inline const ::google::privacy::dlp::v2::BigQueryTable& BigQueryKey::table_reference() const {
  const ::google::privacy::dlp::v2::BigQueryTable* p = table_reference_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryKey.table_reference)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::BigQueryTable*>(
      &::google::privacy::dlp::v2::_BigQueryTable_default_instance_);
}
inline ::google::privacy::dlp::v2::BigQueryTable* BigQueryKey::release_table_reference() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryKey.table_reference)
  
  ::google::privacy::dlp::v2::BigQueryTable* temp = table_reference_;
  table_reference_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::BigQueryTable* BigQueryKey::mutable_table_reference() {
  
  if (table_reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryTable>(GetArenaNoVirtual());
    table_reference_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryKey.table_reference)
  return table_reference_;
}
inline void BigQueryKey::set_allocated_table_reference(::google::privacy::dlp::v2::BigQueryTable* table_reference) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_reference_;
  }
  if (table_reference) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_reference = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_reference, submessage_arena);
    }
    
  } else {
    
  }
  table_reference_ = table_reference;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryKey.table_reference)
}

// int64 row_number = 2;
inline void BigQueryKey::clear_row_number() {
  row_number_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BigQueryKey::row_number() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryKey.row_number)
  return row_number_;
}
inline void BigQueryKey::set_row_number(::google::protobuf::int64 value) {
  
  row_number_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryKey.row_number)
}

// -------------------------------------------------------------------

// DatastoreKey

// .google.privacy.dlp.v2.Key entity_key = 1;
inline bool DatastoreKey::has_entity_key() const {
  return this != internal_default_instance() && entity_key_ != nullptr;
}
inline void DatastoreKey::clear_entity_key() {
  if (GetArenaNoVirtual() == nullptr && entity_key_ != nullptr) {
    delete entity_key_;
  }
  entity_key_ = nullptr;
}
inline const ::google::privacy::dlp::v2::Key& DatastoreKey::entity_key() const {
  const ::google::privacy::dlp::v2::Key* p = entity_key_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.DatastoreKey.entity_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::Key*>(
      &::google::privacy::dlp::v2::_Key_default_instance_);
}
inline ::google::privacy::dlp::v2::Key* DatastoreKey::release_entity_key() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.DatastoreKey.entity_key)
  
  ::google::privacy::dlp::v2::Key* temp = entity_key_;
  entity_key_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::Key* DatastoreKey::mutable_entity_key() {
  
  if (entity_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::Key>(GetArenaNoVirtual());
    entity_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.DatastoreKey.entity_key)
  return entity_key_;
}
inline void DatastoreKey::set_allocated_entity_key(::google::privacy::dlp::v2::Key* entity_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete entity_key_;
  }
  if (entity_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_key, submessage_arena);
    }
    
  } else {
    
  }
  entity_key_ = entity_key;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.DatastoreKey.entity_key)
}

// -------------------------------------------------------------------

// Key_PathElement

// string kind = 1;
inline void Key_PathElement::clear_kind() {
  kind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Key_PathElement::kind() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.Key.PathElement.kind)
  return kind_.GetNoArena();
}
inline void Key_PathElement::set_kind(const ::std::string& value) {
  
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.Key.PathElement.kind)
}
#if LANG_CXX11
inline void Key_PathElement::set_kind(::std::string&& value) {
  
  kind_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.Key.PathElement.kind)
}
#endif
inline void Key_PathElement::set_kind(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.Key.PathElement.kind)
}
inline void Key_PathElement::set_kind(const char* value, size_t size) {
  
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.Key.PathElement.kind)
}
inline ::std::string* Key_PathElement::mutable_kind() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.Key.PathElement.kind)
  return kind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Key_PathElement::release_kind() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.Key.PathElement.kind)
  
  return kind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Key_PathElement::set_allocated_kind(::std::string* kind) {
  if (kind != nullptr) {
    
  } else {
    
  }
  kind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kind);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.Key.PathElement.kind)
}

// int64 id = 2;
inline bool Key_PathElement::has_id() const {
  return id_type_case() == kId;
}
inline void Key_PathElement::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Key_PathElement::clear_id() {
  if (has_id()) {
    id_type_.id_ = PROTOBUF_LONGLONG(0);
    clear_has_id_type();
  }
}
inline ::google::protobuf::int64 Key_PathElement::id() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.Key.PathElement.id)
  if (has_id()) {
    return id_type_.id_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Key_PathElement::set_id(::google::protobuf::int64 value) {
  if (!has_id()) {
    clear_id_type();
    set_has_id();
  }
  id_type_.id_ = value;
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.Key.PathElement.id)
}

// string name = 3;
inline bool Key_PathElement::has_name() const {
  return id_type_case() == kName;
}
inline void Key_PathElement::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void Key_PathElement::clear_name() {
  if (has_name()) {
    id_type_.name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id_type();
  }
}
inline const ::std::string& Key_PathElement::name() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.Key.PathElement.name)
  if (has_name()) {
    return id_type_.name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Key_PathElement::set_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.Key.PathElement.name)
  if (!has_name()) {
    clear_id_type();
    set_has_name();
    id_type_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.Key.PathElement.name)
}
#if LANG_CXX11
inline void Key_PathElement::set_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.Key.PathElement.name)
  if (!has_name()) {
    clear_id_type();
    set_has_name();
    id_type_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.Key.PathElement.name)
}
#endif
inline void Key_PathElement::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_name()) {
    clear_id_type();
    set_has_name();
    id_type_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.Key.PathElement.name)
}
inline void Key_PathElement::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_id_type();
    set_has_name();
    id_type_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.Key.PathElement.name)
}
inline ::std::string* Key_PathElement::mutable_name() {
  if (!has_name()) {
    clear_id_type();
    set_has_name();
    id_type_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.Key.PathElement.name)
  return id_type_.name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Key_PathElement::release_name() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.Key.PathElement.name)
  if (has_name()) {
    clear_has_id_type();
    return id_type_.name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Key_PathElement::set_allocated_name(::std::string* name) {
  if (has_id_type()) {
    clear_id_type();
  }
  if (name != nullptr) {
    set_has_name();
    id_type_.name_.UnsafeSetDefault(name);
  }
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.Key.PathElement.name)
}

inline bool Key_PathElement::has_id_type() const {
  return id_type_case() != ID_TYPE_NOT_SET;
}
inline void Key_PathElement::clear_has_id_type() {
  _oneof_case_[0] = ID_TYPE_NOT_SET;
}
inline Key_PathElement::IdTypeCase Key_PathElement::id_type_case() const {
  return Key_PathElement::IdTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Key

// .google.privacy.dlp.v2.PartitionId partition_id = 1;
inline bool Key::has_partition_id() const {
  return this != internal_default_instance() && partition_id_ != nullptr;
}
inline void Key::clear_partition_id() {
  if (GetArenaNoVirtual() == nullptr && partition_id_ != nullptr) {
    delete partition_id_;
  }
  partition_id_ = nullptr;
}
inline const ::google::privacy::dlp::v2::PartitionId& Key::partition_id() const {
  const ::google::privacy::dlp::v2::PartitionId* p = partition_id_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.Key.partition_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::PartitionId*>(
      &::google::privacy::dlp::v2::_PartitionId_default_instance_);
}
inline ::google::privacy::dlp::v2::PartitionId* Key::release_partition_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.Key.partition_id)
  
  ::google::privacy::dlp::v2::PartitionId* temp = partition_id_;
  partition_id_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::PartitionId* Key::mutable_partition_id() {
  
  if (partition_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::PartitionId>(GetArenaNoVirtual());
    partition_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.Key.partition_id)
  return partition_id_;
}
inline void Key::set_allocated_partition_id(::google::privacy::dlp::v2::PartitionId* partition_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete partition_id_;
  }
  if (partition_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      partition_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, partition_id, submessage_arena);
    }
    
  } else {
    
  }
  partition_id_ = partition_id;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.Key.partition_id)
}

// repeated .google.privacy.dlp.v2.Key.PathElement path = 2;
inline int Key::path_size() const {
  return path_.size();
}
inline void Key::clear_path() {
  path_.Clear();
}
inline ::google::privacy::dlp::v2::Key_PathElement* Key::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.Key.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::Key_PathElement >*
Key::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.Key.path)
  return &path_;
}
inline const ::google::privacy::dlp::v2::Key_PathElement& Key::path(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.Key.path)
  return path_.Get(index);
}
inline ::google::privacy::dlp::v2::Key_PathElement* Key::add_path() {
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.Key.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::Key_PathElement >&
Key::path() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.Key.path)
  return path_;
}

// -------------------------------------------------------------------

// RecordKey

// .google.privacy.dlp.v2.DatastoreKey datastore_key = 2;
inline bool RecordKey::has_datastore_key() const {
  return type_case() == kDatastoreKey;
}
inline void RecordKey::set_has_datastore_key() {
  _oneof_case_[0] = kDatastoreKey;
}
inline void RecordKey::clear_datastore_key() {
  if (has_datastore_key()) {
    delete type_.datastore_key_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::DatastoreKey* RecordKey::release_datastore_key() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.RecordKey.datastore_key)
  if (has_datastore_key()) {
    clear_has_type();
      ::google::privacy::dlp::v2::DatastoreKey* temp = type_.datastore_key_;
    type_.datastore_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::DatastoreKey& RecordKey::datastore_key() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.RecordKey.datastore_key)
  return has_datastore_key()
      ? *type_.datastore_key_
      : *reinterpret_cast< ::google::privacy::dlp::v2::DatastoreKey*>(&::google::privacy::dlp::v2::_DatastoreKey_default_instance_);
}
inline ::google::privacy::dlp::v2::DatastoreKey* RecordKey::mutable_datastore_key() {
  if (!has_datastore_key()) {
    clear_type();
    set_has_datastore_key();
    type_.datastore_key_ = CreateMaybeMessage< ::google::privacy::dlp::v2::DatastoreKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.RecordKey.datastore_key)
  return type_.datastore_key_;
}

// .google.privacy.dlp.v2.BigQueryKey big_query_key = 3;
inline bool RecordKey::has_big_query_key() const {
  return type_case() == kBigQueryKey;
}
inline void RecordKey::set_has_big_query_key() {
  _oneof_case_[0] = kBigQueryKey;
}
inline void RecordKey::clear_big_query_key() {
  if (has_big_query_key()) {
    delete type_.big_query_key_;
    clear_has_type();
  }
}
inline ::google::privacy::dlp::v2::BigQueryKey* RecordKey::release_big_query_key() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.RecordKey.big_query_key)
  if (has_big_query_key()) {
    clear_has_type();
      ::google::privacy::dlp::v2::BigQueryKey* temp = type_.big_query_key_;
    type_.big_query_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::privacy::dlp::v2::BigQueryKey& RecordKey::big_query_key() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.RecordKey.big_query_key)
  return has_big_query_key()
      ? *type_.big_query_key_
      : *reinterpret_cast< ::google::privacy::dlp::v2::BigQueryKey*>(&::google::privacy::dlp::v2::_BigQueryKey_default_instance_);
}
inline ::google::privacy::dlp::v2::BigQueryKey* RecordKey::mutable_big_query_key() {
  if (!has_big_query_key()) {
    clear_type();
    set_has_big_query_key();
    type_.big_query_key_ = CreateMaybeMessage< ::google::privacy::dlp::v2::BigQueryKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.RecordKey.big_query_key)
  return type_.big_query_key_;
}

// repeated string id_values = 5;
inline int RecordKey::id_values_size() const {
  return id_values_.size();
}
inline void RecordKey::clear_id_values() {
  id_values_.Clear();
}
inline const ::std::string& RecordKey::id_values(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.RecordKey.id_values)
  return id_values_.Get(index);
}
inline ::std::string* RecordKey::mutable_id_values(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.RecordKey.id_values)
  return id_values_.Mutable(index);
}
inline void RecordKey::set_id_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.RecordKey.id_values)
  id_values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RecordKey::set_id_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.RecordKey.id_values)
  id_values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RecordKey::set_id_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.RecordKey.id_values)
}
inline void RecordKey::set_id_values(int index, const char* value, size_t size) {
  id_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.RecordKey.id_values)
}
inline ::std::string* RecordKey::add_id_values() {
  // @@protoc_insertion_point(field_add_mutable:google.privacy.dlp.v2.RecordKey.id_values)
  return id_values_.Add();
}
inline void RecordKey::add_id_values(const ::std::string& value) {
  id_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.RecordKey.id_values)
}
#if LANG_CXX11
inline void RecordKey::add_id_values(::std::string&& value) {
  id_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.RecordKey.id_values)
}
#endif
inline void RecordKey::add_id_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.privacy.dlp.v2.RecordKey.id_values)
}
inline void RecordKey::add_id_values(const char* value, size_t size) {
  id_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.privacy.dlp.v2.RecordKey.id_values)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RecordKey::id_values() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.RecordKey.id_values)
  return id_values_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
RecordKey::mutable_id_values() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.RecordKey.id_values)
  return &id_values_;
}

inline bool RecordKey::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RecordKey::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline RecordKey::TypeCase RecordKey::type_case() const {
  return RecordKey::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BigQueryTable

// string project_id = 1;
inline void BigQueryTable::clear_project_id() {
  project_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigQueryTable::project_id() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryTable.project_id)
  return project_id_.GetNoArena();
}
inline void BigQueryTable::set_project_id(const ::std::string& value) {
  
  project_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryTable.project_id)
}
#if LANG_CXX11
inline void BigQueryTable::set_project_id(::std::string&& value) {
  
  project_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.BigQueryTable.project_id)
}
#endif
inline void BigQueryTable::set_project_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.BigQueryTable.project_id)
}
inline void BigQueryTable::set_project_id(const char* value, size_t size) {
  
  project_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.BigQueryTable.project_id)
}
inline ::std::string* BigQueryTable::mutable_project_id() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryTable.project_id)
  return project_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigQueryTable::release_project_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryTable.project_id)
  
  return project_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigQueryTable::set_allocated_project_id(::std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project_id);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryTable.project_id)
}

// string dataset_id = 2;
inline void BigQueryTable::clear_dataset_id() {
  dataset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigQueryTable::dataset_id() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryTable.dataset_id)
  return dataset_id_.GetNoArena();
}
inline void BigQueryTable::set_dataset_id(const ::std::string& value) {
  
  dataset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryTable.dataset_id)
}
#if LANG_CXX11
inline void BigQueryTable::set_dataset_id(::std::string&& value) {
  
  dataset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.BigQueryTable.dataset_id)
}
#endif
inline void BigQueryTable::set_dataset_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dataset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.BigQueryTable.dataset_id)
}
inline void BigQueryTable::set_dataset_id(const char* value, size_t size) {
  
  dataset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.BigQueryTable.dataset_id)
}
inline ::std::string* BigQueryTable::mutable_dataset_id() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryTable.dataset_id)
  return dataset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigQueryTable::release_dataset_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryTable.dataset_id)
  
  return dataset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigQueryTable::set_allocated_dataset_id(::std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  dataset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dataset_id);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryTable.dataset_id)
}

// string table_id = 3;
inline void BigQueryTable::clear_table_id() {
  table_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigQueryTable::table_id() const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryTable.table_id)
  return table_id_.GetNoArena();
}
inline void BigQueryTable::set_table_id(const ::std::string& value) {
  
  table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.privacy.dlp.v2.BigQueryTable.table_id)
}
#if LANG_CXX11
inline void BigQueryTable::set_table_id(::std::string&& value) {
  
  table_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.privacy.dlp.v2.BigQueryTable.table_id)
}
#endif
inline void BigQueryTable::set_table_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.privacy.dlp.v2.BigQueryTable.table_id)
}
inline void BigQueryTable::set_table_id(const char* value, size_t size) {
  
  table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.privacy.dlp.v2.BigQueryTable.table_id)
}
inline ::std::string* BigQueryTable::mutable_table_id() {
  
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryTable.table_id)
  return table_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigQueryTable::release_table_id() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryTable.table_id)
  
  return table_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigQueryTable::set_allocated_table_id(::std::string* table_id) {
  if (table_id != nullptr) {
    
  } else {
    
  }
  table_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_id);
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryTable.table_id)
}

// -------------------------------------------------------------------

// BigQueryField

// .google.privacy.dlp.v2.BigQueryTable table = 1;
inline bool BigQueryField::has_table() const {
  return this != internal_default_instance() && table_ != nullptr;
}
inline void BigQueryField::clear_table() {
  if (GetArenaNoVirtual() == nullptr && table_ != nullptr) {
    delete table_;
  }
  table_ = nullptr;
}
inline const ::google::privacy::dlp::v2::BigQueryTable& BigQueryField::table() const {
  const ::google::privacy::dlp::v2::BigQueryTable* p = table_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryField.table)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::BigQueryTable*>(
      &::google::privacy::dlp::v2::_BigQueryTable_default_instance_);
}
inline ::google::privacy::dlp::v2::BigQueryTable* BigQueryField::release_table() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryField.table)
  
  ::google::privacy::dlp::v2::BigQueryTable* temp = table_;
  table_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::BigQueryTable* BigQueryField::mutable_table() {
  
  if (table_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::BigQueryTable>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryField.table)
  return table_;
}
inline void BigQueryField::set_allocated_table(::google::privacy::dlp::v2::BigQueryTable* table) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_;
  }
  if (table) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryField.table)
}

// .google.privacy.dlp.v2.FieldId field = 2;
inline bool BigQueryField::has_field() const {
  return this != internal_default_instance() && field_ != nullptr;
}
inline void BigQueryField::clear_field() {
  if (GetArenaNoVirtual() == nullptr && field_ != nullptr) {
    delete field_;
  }
  field_ = nullptr;
}
inline const ::google::privacy::dlp::v2::FieldId& BigQueryField::field() const {
  const ::google::privacy::dlp::v2::FieldId* p = field_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.BigQueryField.field)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::FieldId*>(
      &::google::privacy::dlp::v2::_FieldId_default_instance_);
}
inline ::google::privacy::dlp::v2::FieldId* BigQueryField::release_field() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.BigQueryField.field)
  
  ::google::privacy::dlp::v2::FieldId* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::FieldId* BigQueryField::mutable_field() {
  
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::FieldId>(GetArenaNoVirtual());
    field_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.BigQueryField.field)
  return field_;
}
inline void BigQueryField::set_allocated_field(::google::privacy::dlp::v2::FieldId* field) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      field = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    
  } else {
    
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.BigQueryField.field)
}

// -------------------------------------------------------------------

// EntityId

// .google.privacy.dlp.v2.FieldId field = 1;
inline bool EntityId::has_field() const {
  return this != internal_default_instance() && field_ != nullptr;
}
inline void EntityId::clear_field() {
  if (GetArenaNoVirtual() == nullptr && field_ != nullptr) {
    delete field_;
  }
  field_ = nullptr;
}
inline const ::google::privacy::dlp::v2::FieldId& EntityId::field() const {
  const ::google::privacy::dlp::v2::FieldId* p = field_;
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.EntityId.field)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::privacy::dlp::v2::FieldId*>(
      &::google::privacy::dlp::v2::_FieldId_default_instance_);
}
inline ::google::privacy::dlp::v2::FieldId* EntityId::release_field() {
  // @@protoc_insertion_point(field_release:google.privacy.dlp.v2.EntityId.field)
  
  ::google::privacy::dlp::v2::FieldId* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::google::privacy::dlp::v2::FieldId* EntityId::mutable_field() {
  
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::privacy::dlp::v2::FieldId>(GetArenaNoVirtual());
    field_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.EntityId.field)
  return field_;
}
inline void EntityId::set_allocated_field(::google::privacy::dlp::v2::FieldId* field) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      field = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    
  } else {
    
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:google.privacy.dlp.v2.EntityId.field)
}

// -------------------------------------------------------------------

// TableOptions

// repeated .google.privacy.dlp.v2.FieldId identifying_fields = 1;
inline int TableOptions::identifying_fields_size() const {
  return identifying_fields_.size();
}
inline void TableOptions::clear_identifying_fields() {
  identifying_fields_.Clear();
}
inline ::google::privacy::dlp::v2::FieldId* TableOptions::mutable_identifying_fields(int index) {
  // @@protoc_insertion_point(field_mutable:google.privacy.dlp.v2.TableOptions.identifying_fields)
  return identifying_fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >*
TableOptions::mutable_identifying_fields() {
  // @@protoc_insertion_point(field_mutable_list:google.privacy.dlp.v2.TableOptions.identifying_fields)
  return &identifying_fields_;
}
inline const ::google::privacy::dlp::v2::FieldId& TableOptions::identifying_fields(int index) const {
  // @@protoc_insertion_point(field_get:google.privacy.dlp.v2.TableOptions.identifying_fields)
  return identifying_fields_.Get(index);
}
inline ::google::privacy::dlp::v2::FieldId* TableOptions::add_identifying_fields() {
  // @@protoc_insertion_point(field_add:google.privacy.dlp.v2.TableOptions.identifying_fields)
  return identifying_fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::privacy::dlp::v2::FieldId >&
TableOptions::identifying_fields() const {
  // @@protoc_insertion_point(field_list:google.privacy.dlp.v2.TableOptions.identifying_fields)
  return identifying_fields_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace dlp
}  // namespace privacy
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::privacy::dlp::v2::CustomInfoType_ExclusionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::privacy::dlp::v2::CustomInfoType_ExclusionType>() {
  return ::google::privacy::dlp::v2::CustomInfoType_ExclusionType_descriptor();
}
template <> struct is_proto_enum< ::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod>() {
  return ::google::privacy::dlp::v2::CloudStorageOptions_SampleMethod_descriptor();
}
template <> struct is_proto_enum< ::google::privacy::dlp::v2::BigQueryOptions_SampleMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::privacy::dlp::v2::BigQueryOptions_SampleMethod>() {
  return ::google::privacy::dlp::v2::BigQueryOptions_SampleMethod_descriptor();
}
template <> struct is_proto_enum< ::google::privacy::dlp::v2::Likelihood> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::privacy::dlp::v2::Likelihood>() {
  return ::google::privacy::dlp::v2::Likelihood_descriptor();
}
template <> struct is_proto_enum< ::google::privacy::dlp::v2::FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::privacy::dlp::v2::FileType>() {
  return ::google::privacy::dlp::v2::FileType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_google_2fprivacy_2fdlp_2fv2_2fstorage_2eproto
