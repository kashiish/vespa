// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/identity/accesscontextmanager/v1/access_level.proto

#ifndef PROTOBUF_INCLUDED_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto
#define PROTOBUF_INCLUDED_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/identity/accesscontextmanager/type/device_resources.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "google/type/expr.pb.h"
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto();
namespace google {
namespace identity {
namespace accesscontextmanager {
namespace v1 {
class AccessLevel;
class AccessLevelDefaultTypeInternal;
extern AccessLevelDefaultTypeInternal _AccessLevel_default_instance_;
class BasicLevel;
class BasicLevelDefaultTypeInternal;
extern BasicLevelDefaultTypeInternal _BasicLevel_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class CustomLevel;
class CustomLevelDefaultTypeInternal;
extern CustomLevelDefaultTypeInternal _CustomLevel_default_instance_;
class DevicePolicy;
class DevicePolicyDefaultTypeInternal;
extern DevicePolicyDefaultTypeInternal _DevicePolicy_default_instance_;
class OsConstraint;
class OsConstraintDefaultTypeInternal;
extern OsConstraintDefaultTypeInternal _OsConstraint_default_instance_;
}  // namespace v1
}  // namespace accesscontextmanager
}  // namespace identity
namespace protobuf {
template<> ::google::identity::accesscontextmanager::v1::AccessLevel* Arena::CreateMaybeMessage<::google::identity::accesscontextmanager::v1::AccessLevel>(Arena*);
template<> ::google::identity::accesscontextmanager::v1::BasicLevel* Arena::CreateMaybeMessage<::google::identity::accesscontextmanager::v1::BasicLevel>(Arena*);
template<> ::google::identity::accesscontextmanager::v1::Condition* Arena::CreateMaybeMessage<::google::identity::accesscontextmanager::v1::Condition>(Arena*);
template<> ::google::identity::accesscontextmanager::v1::CustomLevel* Arena::CreateMaybeMessage<::google::identity::accesscontextmanager::v1::CustomLevel>(Arena*);
template<> ::google::identity::accesscontextmanager::v1::DevicePolicy* Arena::CreateMaybeMessage<::google::identity::accesscontextmanager::v1::DevicePolicy>(Arena*);
template<> ::google::identity::accesscontextmanager::v1::OsConstraint* Arena::CreateMaybeMessage<::google::identity::accesscontextmanager::v1::OsConstraint>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace google {
namespace identity {
namespace accesscontextmanager {
namespace v1 {

enum BasicLevel_ConditionCombiningFunction {
  BasicLevel_ConditionCombiningFunction_AND = 0,
  BasicLevel_ConditionCombiningFunction_OR = 1,
  BasicLevel_ConditionCombiningFunction_BasicLevel_ConditionCombiningFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  BasicLevel_ConditionCombiningFunction_BasicLevel_ConditionCombiningFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool BasicLevel_ConditionCombiningFunction_IsValid(int value);
const BasicLevel_ConditionCombiningFunction BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_MIN = BasicLevel_ConditionCombiningFunction_AND;
const BasicLevel_ConditionCombiningFunction BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_MAX = BasicLevel_ConditionCombiningFunction_OR;
const int BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_ARRAYSIZE = BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* BasicLevel_ConditionCombiningFunction_descriptor();
inline const ::std::string& BasicLevel_ConditionCombiningFunction_Name(BasicLevel_ConditionCombiningFunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    BasicLevel_ConditionCombiningFunction_descriptor(), value);
}
inline bool BasicLevel_ConditionCombiningFunction_Parse(
    const ::std::string& name, BasicLevel_ConditionCombiningFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BasicLevel_ConditionCombiningFunction>(
    BasicLevel_ConditionCombiningFunction_descriptor(), name, value);
}
// ===================================================================

class AccessLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.identity.accesscontextmanager.v1.AccessLevel) */ {
 public:
  AccessLevel();
  virtual ~AccessLevel();

  AccessLevel(const AccessLevel& from);

  inline AccessLevel& operator=(const AccessLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccessLevel(AccessLevel&& from) noexcept
    : AccessLevel() {
    *this = ::std::move(from);
  }

  inline AccessLevel& operator=(AccessLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AccessLevel& default_instance();

  enum LevelCase {
    kBasic = 4,
    kCustom = 5,
    LEVEL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccessLevel* internal_default_instance() {
    return reinterpret_cast<const AccessLevel*>(
               &_AccessLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AccessLevel* other);
  friend void swap(AccessLevel& a, AccessLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccessLevel* New() const final {
    return CreateMaybeMessage<AccessLevel>(nullptr);
  }

  AccessLevel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccessLevel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccessLevel& from);
  void MergeFrom(const AccessLevel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .google.protobuf.Timestamp create_time = 6;
  bool has_create_time() const;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  const ::google::protobuf::Timestamp& create_time() const;
  ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* create_time);

  // .google.protobuf.Timestamp update_time = 7;
  bool has_update_time() const;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 7;
  const ::google::protobuf::Timestamp& update_time() const;
  ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* update_time);

  // .google.identity.accesscontextmanager.v1.BasicLevel basic = 4;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 4;
  const ::google::identity::accesscontextmanager::v1::BasicLevel& basic() const;
  ::google::identity::accesscontextmanager::v1::BasicLevel* release_basic();
  ::google::identity::accesscontextmanager::v1::BasicLevel* mutable_basic();
  void set_allocated_basic(::google::identity::accesscontextmanager::v1::BasicLevel* basic);

  // .google.identity.accesscontextmanager.v1.CustomLevel custom = 5;
  bool has_custom() const;
  void clear_custom();
  static const int kCustomFieldNumber = 5;
  const ::google::identity::accesscontextmanager::v1::CustomLevel& custom() const;
  ::google::identity::accesscontextmanager::v1::CustomLevel* release_custom();
  ::google::identity::accesscontextmanager::v1::CustomLevel* mutable_custom();
  void set_allocated_custom(::google::identity::accesscontextmanager::v1::CustomLevel* custom);

  void clear_level();
  LevelCase level_case() const;
  // @@protoc_insertion_point(class_scope:google.identity.accesscontextmanager.v1.AccessLevel)
 private:
  class HasBitSetters;
  void set_has_basic();
  void set_has_custom();

  inline bool has_level() const;
  inline void clear_has_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::Timestamp* create_time_;
  ::google::protobuf::Timestamp* update_time_;
  union LevelUnion {
    LevelUnion() {}
    ::google::identity::accesscontextmanager::v1::BasicLevel* basic_;
    ::google::identity::accesscontextmanager::v1::CustomLevel* custom_;
  } level_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto;
};
// -------------------------------------------------------------------

class BasicLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.identity.accesscontextmanager.v1.BasicLevel) */ {
 public:
  BasicLevel();
  virtual ~BasicLevel();

  BasicLevel(const BasicLevel& from);

  inline BasicLevel& operator=(const BasicLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BasicLevel(BasicLevel&& from) noexcept
    : BasicLevel() {
    *this = ::std::move(from);
  }

  inline BasicLevel& operator=(BasicLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BasicLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasicLevel* internal_default_instance() {
    return reinterpret_cast<const BasicLevel*>(
               &_BasicLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BasicLevel* other);
  friend void swap(BasicLevel& a, BasicLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BasicLevel* New() const final {
    return CreateMaybeMessage<BasicLevel>(nullptr);
  }

  BasicLevel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BasicLevel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BasicLevel& from);
  void MergeFrom(const BasicLevel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BasicLevel_ConditionCombiningFunction ConditionCombiningFunction;
  static const ConditionCombiningFunction AND =
    BasicLevel_ConditionCombiningFunction_AND;
  static const ConditionCombiningFunction OR =
    BasicLevel_ConditionCombiningFunction_OR;
  static inline bool ConditionCombiningFunction_IsValid(int value) {
    return BasicLevel_ConditionCombiningFunction_IsValid(value);
  }
  static const ConditionCombiningFunction ConditionCombiningFunction_MIN =
    BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_MIN;
  static const ConditionCombiningFunction ConditionCombiningFunction_MAX =
    BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_MAX;
  static const int ConditionCombiningFunction_ARRAYSIZE =
    BasicLevel_ConditionCombiningFunction_ConditionCombiningFunction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ConditionCombiningFunction_descriptor() {
    return BasicLevel_ConditionCombiningFunction_descriptor();
  }
  static inline const ::std::string& ConditionCombiningFunction_Name(ConditionCombiningFunction value) {
    return BasicLevel_ConditionCombiningFunction_Name(value);
  }
  static inline bool ConditionCombiningFunction_Parse(const ::std::string& name,
      ConditionCombiningFunction* value) {
    return BasicLevel_ConditionCombiningFunction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .google.identity.accesscontextmanager.v1.Condition conditions = 1;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 1;
  ::google::identity::accesscontextmanager::v1::Condition* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::Condition >*
      mutable_conditions();
  const ::google::identity::accesscontextmanager::v1::Condition& conditions(int index) const;
  ::google::identity::accesscontextmanager::v1::Condition* add_conditions();
  const ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::Condition >&
      conditions() const;

  // .google.identity.accesscontextmanager.v1.BasicLevel.ConditionCombiningFunction combining_function = 2;
  void clear_combining_function();
  static const int kCombiningFunctionFieldNumber = 2;
  ::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction combining_function() const;
  void set_combining_function(::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction value);

  // @@protoc_insertion_point(class_scope:google.identity.accesscontextmanager.v1.BasicLevel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::Condition > conditions_;
  int combining_function_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto;
};
// -------------------------------------------------------------------

class Condition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.identity.accesscontextmanager.v1.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ip_subnetworks = 1;
  int ip_subnetworks_size() const;
  void clear_ip_subnetworks();
  static const int kIpSubnetworksFieldNumber = 1;
  const ::std::string& ip_subnetworks(int index) const;
  ::std::string* mutable_ip_subnetworks(int index);
  void set_ip_subnetworks(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ip_subnetworks(int index, ::std::string&& value);
  #endif
  void set_ip_subnetworks(int index, const char* value);
  void set_ip_subnetworks(int index, const char* value, size_t size);
  ::std::string* add_ip_subnetworks();
  void add_ip_subnetworks(const ::std::string& value);
  #if LANG_CXX11
  void add_ip_subnetworks(::std::string&& value);
  #endif
  void add_ip_subnetworks(const char* value);
  void add_ip_subnetworks(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& ip_subnetworks() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_ip_subnetworks();

  // repeated string required_access_levels = 3;
  int required_access_levels_size() const;
  void clear_required_access_levels();
  static const int kRequiredAccessLevelsFieldNumber = 3;
  const ::std::string& required_access_levels(int index) const;
  ::std::string* mutable_required_access_levels(int index);
  void set_required_access_levels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_required_access_levels(int index, ::std::string&& value);
  #endif
  void set_required_access_levels(int index, const char* value);
  void set_required_access_levels(int index, const char* value, size_t size);
  ::std::string* add_required_access_levels();
  void add_required_access_levels(const ::std::string& value);
  #if LANG_CXX11
  void add_required_access_levels(::std::string&& value);
  #endif
  void add_required_access_levels(const char* value);
  void add_required_access_levels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& required_access_levels() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_required_access_levels();

  // repeated string members = 6;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 6;
  const ::std::string& members(int index) const;
  ::std::string* mutable_members(int index);
  void set_members(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_members(int index, ::std::string&& value);
  #endif
  void set_members(int index, const char* value);
  void set_members(int index, const char* value, size_t size);
  ::std::string* add_members();
  void add_members(const ::std::string& value);
  #if LANG_CXX11
  void add_members(::std::string&& value);
  #endif
  void add_members(const char* value);
  void add_members(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& members() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_members();

  // repeated string regions = 7;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 7;
  const ::std::string& regions(int index) const;
  ::std::string* mutable_regions(int index);
  void set_regions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_regions(int index, ::std::string&& value);
  #endif
  void set_regions(int index, const char* value);
  void set_regions(int index, const char* value, size_t size);
  ::std::string* add_regions();
  void add_regions(const ::std::string& value);
  #if LANG_CXX11
  void add_regions(::std::string&& value);
  #endif
  void add_regions(const char* value);
  void add_regions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& regions() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_regions();

  // .google.identity.accesscontextmanager.v1.DevicePolicy device_policy = 2;
  bool has_device_policy() const;
  void clear_device_policy();
  static const int kDevicePolicyFieldNumber = 2;
  const ::google::identity::accesscontextmanager::v1::DevicePolicy& device_policy() const;
  ::google::identity::accesscontextmanager::v1::DevicePolicy* release_device_policy();
  ::google::identity::accesscontextmanager::v1::DevicePolicy* mutable_device_policy();
  void set_allocated_device_policy(::google::identity::accesscontextmanager::v1::DevicePolicy* device_policy);

  // bool negate = 5;
  void clear_negate();
  static const int kNegateFieldNumber = 5;
  bool negate() const;
  void set_negate(bool value);

  // @@protoc_insertion_point(class_scope:google.identity.accesscontextmanager.v1.Condition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> ip_subnetworks_;
  ::google::protobuf::RepeatedPtrField<::std::string> required_access_levels_;
  ::google::protobuf::RepeatedPtrField<::std::string> members_;
  ::google::protobuf::RepeatedPtrField<::std::string> regions_;
  ::google::identity::accesscontextmanager::v1::DevicePolicy* device_policy_;
  bool negate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto;
};
// -------------------------------------------------------------------

class CustomLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.identity.accesscontextmanager.v1.CustomLevel) */ {
 public:
  CustomLevel();
  virtual ~CustomLevel();

  CustomLevel(const CustomLevel& from);

  inline CustomLevel& operator=(const CustomLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomLevel(CustomLevel&& from) noexcept
    : CustomLevel() {
    *this = ::std::move(from);
  }

  inline CustomLevel& operator=(CustomLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CustomLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomLevel* internal_default_instance() {
    return reinterpret_cast<const CustomLevel*>(
               &_CustomLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CustomLevel* other);
  friend void swap(CustomLevel& a, CustomLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomLevel* New() const final {
    return CreateMaybeMessage<CustomLevel>(nullptr);
  }

  CustomLevel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomLevel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomLevel& from);
  void MergeFrom(const CustomLevel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.type.Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::google::type::Expr& expr() const;
  ::google::type::Expr* release_expr();
  ::google::type::Expr* mutable_expr();
  void set_allocated_expr(::google::type::Expr* expr);

  // @@protoc_insertion_point(class_scope:google.identity.accesscontextmanager.v1.CustomLevel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::type::Expr* expr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto;
};
// -------------------------------------------------------------------

class DevicePolicy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.identity.accesscontextmanager.v1.DevicePolicy) */ {
 public:
  DevicePolicy();
  virtual ~DevicePolicy();

  DevicePolicy(const DevicePolicy& from);

  inline DevicePolicy& operator=(const DevicePolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DevicePolicy(DevicePolicy&& from) noexcept
    : DevicePolicy() {
    *this = ::std::move(from);
  }

  inline DevicePolicy& operator=(DevicePolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DevicePolicy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DevicePolicy* internal_default_instance() {
    return reinterpret_cast<const DevicePolicy*>(
               &_DevicePolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DevicePolicy* other);
  friend void swap(DevicePolicy& a, DevicePolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DevicePolicy* New() const final {
    return CreateMaybeMessage<DevicePolicy>(nullptr);
  }

  DevicePolicy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DevicePolicy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DevicePolicy& from);
  void MergeFrom(const DevicePolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevicePolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.identity.accesscontextmanager.type.DeviceEncryptionStatus allowed_encryption_statuses = 2;
  int allowed_encryption_statuses_size() const;
  void clear_allowed_encryption_statuses();
  static const int kAllowedEncryptionStatusesFieldNumber = 2;
  ::google::identity::accesscontextmanager::type::DeviceEncryptionStatus allowed_encryption_statuses(int index) const;
  void set_allowed_encryption_statuses(int index, ::google::identity::accesscontextmanager::type::DeviceEncryptionStatus value);
  void add_allowed_encryption_statuses(::google::identity::accesscontextmanager::type::DeviceEncryptionStatus value);
  const ::google::protobuf::RepeatedField<int>& allowed_encryption_statuses() const;
  ::google::protobuf::RepeatedField<int>* mutable_allowed_encryption_statuses();

  // repeated .google.identity.accesscontextmanager.v1.OsConstraint os_constraints = 3;
  int os_constraints_size() const;
  void clear_os_constraints();
  static const int kOsConstraintsFieldNumber = 3;
  ::google::identity::accesscontextmanager::v1::OsConstraint* mutable_os_constraints(int index);
  ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::OsConstraint >*
      mutable_os_constraints();
  const ::google::identity::accesscontextmanager::v1::OsConstraint& os_constraints(int index) const;
  ::google::identity::accesscontextmanager::v1::OsConstraint* add_os_constraints();
  const ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::OsConstraint >&
      os_constraints() const;

  // repeated .google.identity.accesscontextmanager.type.DeviceManagementLevel allowed_device_management_levels = 6;
  int allowed_device_management_levels_size() const;
  void clear_allowed_device_management_levels();
  static const int kAllowedDeviceManagementLevelsFieldNumber = 6;
  ::google::identity::accesscontextmanager::type::DeviceManagementLevel allowed_device_management_levels(int index) const;
  void set_allowed_device_management_levels(int index, ::google::identity::accesscontextmanager::type::DeviceManagementLevel value);
  void add_allowed_device_management_levels(::google::identity::accesscontextmanager::type::DeviceManagementLevel value);
  const ::google::protobuf::RepeatedField<int>& allowed_device_management_levels() const;
  ::google::protobuf::RepeatedField<int>* mutable_allowed_device_management_levels();

  // bool require_screenlock = 1;
  void clear_require_screenlock();
  static const int kRequireScreenlockFieldNumber = 1;
  bool require_screenlock() const;
  void set_require_screenlock(bool value);

  // bool require_admin_approval = 7;
  void clear_require_admin_approval();
  static const int kRequireAdminApprovalFieldNumber = 7;
  bool require_admin_approval() const;
  void set_require_admin_approval(bool value);

  // bool require_corp_owned = 8;
  void clear_require_corp_owned();
  static const int kRequireCorpOwnedFieldNumber = 8;
  bool require_corp_owned() const;
  void set_require_corp_owned(bool value);

  // @@protoc_insertion_point(class_scope:google.identity.accesscontextmanager.v1.DevicePolicy)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> allowed_encryption_statuses_;
  mutable std::atomic<int> _allowed_encryption_statuses_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::OsConstraint > os_constraints_;
  ::google::protobuf::RepeatedField<int> allowed_device_management_levels_;
  mutable std::atomic<int> _allowed_device_management_levels_cached_byte_size_;
  bool require_screenlock_;
  bool require_admin_approval_;
  bool require_corp_owned_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto;
};
// -------------------------------------------------------------------

class OsConstraint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.identity.accesscontextmanager.v1.OsConstraint) */ {
 public:
  OsConstraint();
  virtual ~OsConstraint();

  OsConstraint(const OsConstraint& from);

  inline OsConstraint& operator=(const OsConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OsConstraint(OsConstraint&& from) noexcept
    : OsConstraint() {
    *this = ::std::move(from);
  }

  inline OsConstraint& operator=(OsConstraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OsConstraint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OsConstraint* internal_default_instance() {
    return reinterpret_cast<const OsConstraint*>(
               &_OsConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OsConstraint* other);
  friend void swap(OsConstraint& a, OsConstraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OsConstraint* New() const final {
    return CreateMaybeMessage<OsConstraint>(nullptr);
  }

  OsConstraint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OsConstraint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OsConstraint& from);
  void MergeFrom(const OsConstraint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OsConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string minimum_version = 2;
  void clear_minimum_version();
  static const int kMinimumVersionFieldNumber = 2;
  const ::std::string& minimum_version() const;
  void set_minimum_version(const ::std::string& value);
  #if LANG_CXX11
  void set_minimum_version(::std::string&& value);
  #endif
  void set_minimum_version(const char* value);
  void set_minimum_version(const char* value, size_t size);
  ::std::string* mutable_minimum_version();
  ::std::string* release_minimum_version();
  void set_allocated_minimum_version(::std::string* minimum_version);

  // .google.identity.accesscontextmanager.type.OsType os_type = 1;
  void clear_os_type();
  static const int kOsTypeFieldNumber = 1;
  ::google::identity::accesscontextmanager::type::OsType os_type() const;
  void set_os_type(::google::identity::accesscontextmanager::type::OsType value);

  // bool require_verified_chrome_os = 3;
  void clear_require_verified_chrome_os();
  static const int kRequireVerifiedChromeOsFieldNumber = 3;
  bool require_verified_chrome_os() const;
  void set_require_verified_chrome_os(bool value);

  // @@protoc_insertion_point(class_scope:google.identity.accesscontextmanager.v1.OsConstraint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr minimum_version_;
  int os_type_;
  bool require_verified_chrome_os_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccessLevel

// string name = 1;
inline void AccessLevel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLevel::name() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.name)
  return name_.GetNoArena();
}
inline void AccessLevel::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.AccessLevel.name)
}
#if LANG_CXX11
inline void AccessLevel::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.identity.accesscontextmanager.v1.AccessLevel.name)
}
#endif
inline void AccessLevel::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.AccessLevel.name)
}
inline void AccessLevel::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.AccessLevel.name)
}
inline ::std::string* AccessLevel::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLevel::release_name() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLevel::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.AccessLevel.name)
}

// string title = 2;
inline void AccessLevel::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLevel::title() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.title)
  return title_.GetNoArena();
}
inline void AccessLevel::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.AccessLevel.title)
}
#if LANG_CXX11
inline void AccessLevel::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.identity.accesscontextmanager.v1.AccessLevel.title)
}
#endif
inline void AccessLevel::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.AccessLevel.title)
}
inline void AccessLevel::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.AccessLevel.title)
}
inline ::std::string* AccessLevel::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLevel::release_title() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLevel::set_allocated_title(::std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.AccessLevel.title)
}

// string description = 3;
inline void AccessLevel::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessLevel::description() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.description)
  return description_.GetNoArena();
}
inline void AccessLevel::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.AccessLevel.description)
}
#if LANG_CXX11
inline void AccessLevel::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.identity.accesscontextmanager.v1.AccessLevel.description)
}
#endif
inline void AccessLevel::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.AccessLevel.description)
}
inline void AccessLevel::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.AccessLevel.description)
}
inline ::std::string* AccessLevel::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessLevel::release_description() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessLevel::set_allocated_description(::std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.AccessLevel.description)
}

// .google.identity.accesscontextmanager.v1.BasicLevel basic = 4;
inline bool AccessLevel::has_basic() const {
  return level_case() == kBasic;
}
inline void AccessLevel::set_has_basic() {
  _oneof_case_[0] = kBasic;
}
inline void AccessLevel::clear_basic() {
  if (has_basic()) {
    delete level_.basic_;
    clear_has_level();
  }
}
inline ::google::identity::accesscontextmanager::v1::BasicLevel* AccessLevel::release_basic() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.basic)
  if (has_basic()) {
    clear_has_level();
      ::google::identity::accesscontextmanager::v1::BasicLevel* temp = level_.basic_;
    level_.basic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::identity::accesscontextmanager::v1::BasicLevel& AccessLevel::basic() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.basic)
  return has_basic()
      ? *level_.basic_
      : *reinterpret_cast< ::google::identity::accesscontextmanager::v1::BasicLevel*>(&::google::identity::accesscontextmanager::v1::_BasicLevel_default_instance_);
}
inline ::google::identity::accesscontextmanager::v1::BasicLevel* AccessLevel::mutable_basic() {
  if (!has_basic()) {
    clear_level();
    set_has_basic();
    level_.basic_ = CreateMaybeMessage< ::google::identity::accesscontextmanager::v1::BasicLevel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.basic)
  return level_.basic_;
}

// .google.identity.accesscontextmanager.v1.CustomLevel custom = 5;
inline bool AccessLevel::has_custom() const {
  return level_case() == kCustom;
}
inline void AccessLevel::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void AccessLevel::clear_custom() {
  if (has_custom()) {
    delete level_.custom_;
    clear_has_level();
  }
}
inline ::google::identity::accesscontextmanager::v1::CustomLevel* AccessLevel::release_custom() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.custom)
  if (has_custom()) {
    clear_has_level();
      ::google::identity::accesscontextmanager::v1::CustomLevel* temp = level_.custom_;
    level_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::identity::accesscontextmanager::v1::CustomLevel& AccessLevel::custom() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.custom)
  return has_custom()
      ? *level_.custom_
      : *reinterpret_cast< ::google::identity::accesscontextmanager::v1::CustomLevel*>(&::google::identity::accesscontextmanager::v1::_CustomLevel_default_instance_);
}
inline ::google::identity::accesscontextmanager::v1::CustomLevel* AccessLevel::mutable_custom() {
  if (!has_custom()) {
    clear_level();
    set_has_custom();
    level_.custom_ = CreateMaybeMessage< ::google::identity::accesscontextmanager::v1::CustomLevel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.custom)
  return level_.custom_;
}

// .google.protobuf.Timestamp create_time = 6;
inline bool AccessLevel::has_create_time() const {
  return this != internal_default_instance() && create_time_ != nullptr;
}
inline const ::google::protobuf::Timestamp& AccessLevel::create_time() const {
  const ::google::protobuf::Timestamp* p = create_time_;
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.create_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* AccessLevel::release_create_time() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.create_time)
  
  ::google::protobuf::Timestamp* temp = create_time_;
  create_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AccessLevel::mutable_create_time() {
  
  if (create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    create_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.create_time)
  return create_time_;
}
inline void AccessLevel::set_allocated_create_time(::google::protobuf::Timestamp* create_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(create_time_);
  }
  if (create_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(create_time)->GetArena();
    if (message_arena != submessage_arena) {
      create_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.AccessLevel.create_time)
}

// .google.protobuf.Timestamp update_time = 7;
inline bool AccessLevel::has_update_time() const {
  return this != internal_default_instance() && update_time_ != nullptr;
}
inline const ::google::protobuf::Timestamp& AccessLevel::update_time() const {
  const ::google::protobuf::Timestamp* p = update_time_;
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.AccessLevel.update_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* AccessLevel::release_update_time() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.AccessLevel.update_time)
  
  ::google::protobuf::Timestamp* temp = update_time_;
  update_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AccessLevel::mutable_update_time() {
  
  if (update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    update_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.AccessLevel.update_time)
  return update_time_;
}
inline void AccessLevel::set_allocated_update_time(::google::protobuf::Timestamp* update_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.AccessLevel.update_time)
}

inline bool AccessLevel::has_level() const {
  return level_case() != LEVEL_NOT_SET;
}
inline void AccessLevel::clear_has_level() {
  _oneof_case_[0] = LEVEL_NOT_SET;
}
inline AccessLevel::LevelCase AccessLevel::level_case() const {
  return AccessLevel::LevelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BasicLevel

// repeated .google.identity.accesscontextmanager.v1.Condition conditions = 1;
inline int BasicLevel::conditions_size() const {
  return conditions_.size();
}
inline void BasicLevel::clear_conditions() {
  conditions_.Clear();
}
inline ::google::identity::accesscontextmanager::v1::Condition* BasicLevel::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.BasicLevel.conditions)
  return conditions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::Condition >*
BasicLevel::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.BasicLevel.conditions)
  return &conditions_;
}
inline const ::google::identity::accesscontextmanager::v1::Condition& BasicLevel::conditions(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.BasicLevel.conditions)
  return conditions_.Get(index);
}
inline ::google::identity::accesscontextmanager::v1::Condition* BasicLevel::add_conditions() {
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.BasicLevel.conditions)
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::Condition >&
BasicLevel::conditions() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.BasicLevel.conditions)
  return conditions_;
}

// .google.identity.accesscontextmanager.v1.BasicLevel.ConditionCombiningFunction combining_function = 2;
inline void BasicLevel::clear_combining_function() {
  combining_function_ = 0;
}
inline ::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction BasicLevel::combining_function() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.BasicLevel.combining_function)
  return static_cast< ::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction >(combining_function_);
}
inline void BasicLevel::set_combining_function(::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction value) {
  
  combining_function_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.BasicLevel.combining_function)
}

// -------------------------------------------------------------------

// Condition

// repeated string ip_subnetworks = 1;
inline int Condition::ip_subnetworks_size() const {
  return ip_subnetworks_.size();
}
inline void Condition::clear_ip_subnetworks() {
  ip_subnetworks_.Clear();
}
inline const ::std::string& Condition::ip_subnetworks(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  return ip_subnetworks_.Get(index);
}
inline ::std::string* Condition::mutable_ip_subnetworks(int index) {
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  return ip_subnetworks_.Mutable(index);
}
inline void Condition::set_ip_subnetworks(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  ip_subnetworks_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Condition::set_ip_subnetworks(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  ip_subnetworks_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Condition::set_ip_subnetworks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_subnetworks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
}
inline void Condition::set_ip_subnetworks(int index, const char* value, size_t size) {
  ip_subnetworks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
}
inline ::std::string* Condition::add_ip_subnetworks() {
  // @@protoc_insertion_point(field_add_mutable:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  return ip_subnetworks_.Add();
}
inline void Condition::add_ip_subnetworks(const ::std::string& value) {
  ip_subnetworks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
}
#if LANG_CXX11
inline void Condition::add_ip_subnetworks(::std::string&& value) {
  ip_subnetworks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
}
#endif
inline void Condition::add_ip_subnetworks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_subnetworks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
}
inline void Condition::add_ip_subnetworks(const char* value, size_t size) {
  ip_subnetworks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Condition::ip_subnetworks() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  return ip_subnetworks_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Condition::mutable_ip_subnetworks() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.Condition.ip_subnetworks)
  return &ip_subnetworks_;
}

// .google.identity.accesscontextmanager.v1.DevicePolicy device_policy = 2;
inline bool Condition::has_device_policy() const {
  return this != internal_default_instance() && device_policy_ != nullptr;
}
inline void Condition::clear_device_policy() {
  if (GetArenaNoVirtual() == nullptr && device_policy_ != nullptr) {
    delete device_policy_;
  }
  device_policy_ = nullptr;
}
inline const ::google::identity::accesscontextmanager::v1::DevicePolicy& Condition::device_policy() const {
  const ::google::identity::accesscontextmanager::v1::DevicePolicy* p = device_policy_;
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.Condition.device_policy)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::identity::accesscontextmanager::v1::DevicePolicy*>(
      &::google::identity::accesscontextmanager::v1::_DevicePolicy_default_instance_);
}
inline ::google::identity::accesscontextmanager::v1::DevicePolicy* Condition::release_device_policy() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.Condition.device_policy)
  
  ::google::identity::accesscontextmanager::v1::DevicePolicy* temp = device_policy_;
  device_policy_ = nullptr;
  return temp;
}
inline ::google::identity::accesscontextmanager::v1::DevicePolicy* Condition::mutable_device_policy() {
  
  if (device_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::identity::accesscontextmanager::v1::DevicePolicy>(GetArenaNoVirtual());
    device_policy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.Condition.device_policy)
  return device_policy_;
}
inline void Condition::set_allocated_device_policy(::google::identity::accesscontextmanager::v1::DevicePolicy* device_policy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_policy_;
  }
  if (device_policy) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_policy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_policy, submessage_arena);
    }
    
  } else {
    
  }
  device_policy_ = device_policy;
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.Condition.device_policy)
}

// repeated string required_access_levels = 3;
inline int Condition::required_access_levels_size() const {
  return required_access_levels_.size();
}
inline void Condition::clear_required_access_levels() {
  required_access_levels_.Clear();
}
inline const ::std::string& Condition::required_access_levels(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  return required_access_levels_.Get(index);
}
inline ::std::string* Condition::mutable_required_access_levels(int index) {
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  return required_access_levels_.Mutable(index);
}
inline void Condition::set_required_access_levels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  required_access_levels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Condition::set_required_access_levels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  required_access_levels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Condition::set_required_access_levels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_access_levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
}
inline void Condition::set_required_access_levels(int index, const char* value, size_t size) {
  required_access_levels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
}
inline ::std::string* Condition::add_required_access_levels() {
  // @@protoc_insertion_point(field_add_mutable:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  return required_access_levels_.Add();
}
inline void Condition::add_required_access_levels(const ::std::string& value) {
  required_access_levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
}
#if LANG_CXX11
inline void Condition::add_required_access_levels(::std::string&& value) {
  required_access_levels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
}
#endif
inline void Condition::add_required_access_levels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_access_levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
}
inline void Condition::add_required_access_levels(const char* value, size_t size) {
  required_access_levels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Condition::required_access_levels() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  return required_access_levels_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Condition::mutable_required_access_levels() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.Condition.required_access_levels)
  return &required_access_levels_;
}

// bool negate = 5;
inline void Condition::clear_negate() {
  negate_ = false;
}
inline bool Condition::negate() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.Condition.negate)
  return negate_;
}
inline void Condition::set_negate(bool value) {
  
  negate_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.negate)
}

// repeated string members = 6;
inline int Condition::members_size() const {
  return members_.size();
}
inline void Condition::clear_members() {
  members_.Clear();
}
inline const ::std::string& Condition::members(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.Condition.members)
  return members_.Get(index);
}
inline ::std::string* Condition::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.Condition.members)
  return members_.Mutable(index);
}
inline void Condition::set_members(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.members)
  members_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Condition::set_members(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.members)
  members_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Condition::set_members(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.Condition.members)
}
inline void Condition::set_members(int index, const char* value, size_t size) {
  members_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.Condition.members)
}
inline ::std::string* Condition::add_members() {
  // @@protoc_insertion_point(field_add_mutable:google.identity.accesscontextmanager.v1.Condition.members)
  return members_.Add();
}
inline void Condition::add_members(const ::std::string& value) {
  members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.members)
}
#if LANG_CXX11
inline void Condition::add_members(::std::string&& value) {
  members_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.members)
}
#endif
inline void Condition::add_members(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.identity.accesscontextmanager.v1.Condition.members)
}
inline void Condition::add_members(const char* value, size_t size) {
  members_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.identity.accesscontextmanager.v1.Condition.members)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Condition::members() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.Condition.members)
  return members_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Condition::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.Condition.members)
  return &members_;
}

// repeated string regions = 7;
inline int Condition::regions_size() const {
  return regions_.size();
}
inline void Condition::clear_regions() {
  regions_.Clear();
}
inline const ::std::string& Condition::regions(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.Condition.regions)
  return regions_.Get(index);
}
inline ::std::string* Condition::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.Condition.regions)
  return regions_.Mutable(index);
}
inline void Condition::set_regions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.regions)
  regions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Condition::set_regions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.Condition.regions)
  regions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Condition::set_regions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  regions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.Condition.regions)
}
inline void Condition::set_regions(int index, const char* value, size_t size) {
  regions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.Condition.regions)
}
inline ::std::string* Condition::add_regions() {
  // @@protoc_insertion_point(field_add_mutable:google.identity.accesscontextmanager.v1.Condition.regions)
  return regions_.Add();
}
inline void Condition::add_regions(const ::std::string& value) {
  regions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.regions)
}
#if LANG_CXX11
inline void Condition::add_regions(::std::string&& value) {
  regions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.Condition.regions)
}
#endif
inline void Condition::add_regions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  regions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.identity.accesscontextmanager.v1.Condition.regions)
}
inline void Condition::add_regions(const char* value, size_t size) {
  regions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.identity.accesscontextmanager.v1.Condition.regions)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Condition::regions() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.Condition.regions)
  return regions_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Condition::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.Condition.regions)
  return &regions_;
}

// -------------------------------------------------------------------

// CustomLevel

// .google.type.Expr expr = 1;
inline bool CustomLevel::has_expr() const {
  return this != internal_default_instance() && expr_ != nullptr;
}
inline const ::google::type::Expr& CustomLevel::expr() const {
  const ::google::type::Expr* p = expr_;
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.CustomLevel.expr)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::type::Expr*>(
      &::google::type::_Expr_default_instance_);
}
inline ::google::type::Expr* CustomLevel::release_expr() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.CustomLevel.expr)
  
  ::google::type::Expr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::google::type::Expr* CustomLevel::mutable_expr() {
  
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::Expr>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.CustomLevel.expr)
  return expr_;
}
inline void CustomLevel::set_allocated_expr(::google::type::Expr* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(expr_);
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.CustomLevel.expr)
}

// -------------------------------------------------------------------

// DevicePolicy

// bool require_screenlock = 1;
inline void DevicePolicy::clear_require_screenlock() {
  require_screenlock_ = false;
}
inline bool DevicePolicy::require_screenlock() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.DevicePolicy.require_screenlock)
  return require_screenlock_;
}
inline void DevicePolicy::set_require_screenlock(bool value) {
  
  require_screenlock_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.DevicePolicy.require_screenlock)
}

// repeated .google.identity.accesscontextmanager.type.DeviceEncryptionStatus allowed_encryption_statuses = 2;
inline int DevicePolicy::allowed_encryption_statuses_size() const {
  return allowed_encryption_statuses_.size();
}
inline void DevicePolicy::clear_allowed_encryption_statuses() {
  allowed_encryption_statuses_.Clear();
}
inline ::google::identity::accesscontextmanager::type::DeviceEncryptionStatus DevicePolicy::allowed_encryption_statuses(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_encryption_statuses)
  return static_cast< ::google::identity::accesscontextmanager::type::DeviceEncryptionStatus >(allowed_encryption_statuses_.Get(index));
}
inline void DevicePolicy::set_allowed_encryption_statuses(int index, ::google::identity::accesscontextmanager::type::DeviceEncryptionStatus value) {
  allowed_encryption_statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_encryption_statuses)
}
inline void DevicePolicy::add_allowed_encryption_statuses(::google::identity::accesscontextmanager::type::DeviceEncryptionStatus value) {
  allowed_encryption_statuses_.Add(value);
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_encryption_statuses)
}
inline const ::google::protobuf::RepeatedField<int>&
DevicePolicy::allowed_encryption_statuses() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_encryption_statuses)
  return allowed_encryption_statuses_;
}
inline ::google::protobuf::RepeatedField<int>*
DevicePolicy::mutable_allowed_encryption_statuses() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_encryption_statuses)
  return &allowed_encryption_statuses_;
}

// repeated .google.identity.accesscontextmanager.v1.OsConstraint os_constraints = 3;
inline int DevicePolicy::os_constraints_size() const {
  return os_constraints_.size();
}
inline void DevicePolicy::clear_os_constraints() {
  os_constraints_.Clear();
}
inline ::google::identity::accesscontextmanager::v1::OsConstraint* DevicePolicy::mutable_os_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.DevicePolicy.os_constraints)
  return os_constraints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::OsConstraint >*
DevicePolicy::mutable_os_constraints() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.DevicePolicy.os_constraints)
  return &os_constraints_;
}
inline const ::google::identity::accesscontextmanager::v1::OsConstraint& DevicePolicy::os_constraints(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.DevicePolicy.os_constraints)
  return os_constraints_.Get(index);
}
inline ::google::identity::accesscontextmanager::v1::OsConstraint* DevicePolicy::add_os_constraints() {
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.DevicePolicy.os_constraints)
  return os_constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::identity::accesscontextmanager::v1::OsConstraint >&
DevicePolicy::os_constraints() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.DevicePolicy.os_constraints)
  return os_constraints_;
}

// repeated .google.identity.accesscontextmanager.type.DeviceManagementLevel allowed_device_management_levels = 6;
inline int DevicePolicy::allowed_device_management_levels_size() const {
  return allowed_device_management_levels_.size();
}
inline void DevicePolicy::clear_allowed_device_management_levels() {
  allowed_device_management_levels_.Clear();
}
inline ::google::identity::accesscontextmanager::type::DeviceManagementLevel DevicePolicy::allowed_device_management_levels(int index) const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_device_management_levels)
  return static_cast< ::google::identity::accesscontextmanager::type::DeviceManagementLevel >(allowed_device_management_levels_.Get(index));
}
inline void DevicePolicy::set_allowed_device_management_levels(int index, ::google::identity::accesscontextmanager::type::DeviceManagementLevel value) {
  allowed_device_management_levels_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_device_management_levels)
}
inline void DevicePolicy::add_allowed_device_management_levels(::google::identity::accesscontextmanager::type::DeviceManagementLevel value) {
  allowed_device_management_levels_.Add(value);
  // @@protoc_insertion_point(field_add:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_device_management_levels)
}
inline const ::google::protobuf::RepeatedField<int>&
DevicePolicy::allowed_device_management_levels() const {
  // @@protoc_insertion_point(field_list:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_device_management_levels)
  return allowed_device_management_levels_;
}
inline ::google::protobuf::RepeatedField<int>*
DevicePolicy::mutable_allowed_device_management_levels() {
  // @@protoc_insertion_point(field_mutable_list:google.identity.accesscontextmanager.v1.DevicePolicy.allowed_device_management_levels)
  return &allowed_device_management_levels_;
}

// bool require_admin_approval = 7;
inline void DevicePolicy::clear_require_admin_approval() {
  require_admin_approval_ = false;
}
inline bool DevicePolicy::require_admin_approval() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.DevicePolicy.require_admin_approval)
  return require_admin_approval_;
}
inline void DevicePolicy::set_require_admin_approval(bool value) {
  
  require_admin_approval_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.DevicePolicy.require_admin_approval)
}

// bool require_corp_owned = 8;
inline void DevicePolicy::clear_require_corp_owned() {
  require_corp_owned_ = false;
}
inline bool DevicePolicy::require_corp_owned() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.DevicePolicy.require_corp_owned)
  return require_corp_owned_;
}
inline void DevicePolicy::set_require_corp_owned(bool value) {
  
  require_corp_owned_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.DevicePolicy.require_corp_owned)
}

// -------------------------------------------------------------------

// OsConstraint

// .google.identity.accesscontextmanager.type.OsType os_type = 1;
inline void OsConstraint::clear_os_type() {
  os_type_ = 0;
}
inline ::google::identity::accesscontextmanager::type::OsType OsConstraint::os_type() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.OsConstraint.os_type)
  return static_cast< ::google::identity::accesscontextmanager::type::OsType >(os_type_);
}
inline void OsConstraint::set_os_type(::google::identity::accesscontextmanager::type::OsType value) {
  
  os_type_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.OsConstraint.os_type)
}

// string minimum_version = 2;
inline void OsConstraint::clear_minimum_version() {
  minimum_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OsConstraint::minimum_version() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
  return minimum_version_.GetNoArena();
}
inline void OsConstraint::set_minimum_version(const ::std::string& value) {
  
  minimum_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
}
#if LANG_CXX11
inline void OsConstraint::set_minimum_version(::std::string&& value) {
  
  minimum_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
}
#endif
inline void OsConstraint::set_minimum_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  minimum_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
}
inline void OsConstraint::set_minimum_version(const char* value, size_t size) {
  
  minimum_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
}
inline ::std::string* OsConstraint::mutable_minimum_version() {
  
  // @@protoc_insertion_point(field_mutable:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
  return minimum_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OsConstraint::release_minimum_version() {
  // @@protoc_insertion_point(field_release:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
  
  return minimum_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OsConstraint::set_allocated_minimum_version(::std::string* minimum_version) {
  if (minimum_version != nullptr) {
    
  } else {
    
  }
  minimum_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), minimum_version);
  // @@protoc_insertion_point(field_set_allocated:google.identity.accesscontextmanager.v1.OsConstraint.minimum_version)
}

// bool require_verified_chrome_os = 3;
inline void OsConstraint::clear_require_verified_chrome_os() {
  require_verified_chrome_os_ = false;
}
inline bool OsConstraint::require_verified_chrome_os() const {
  // @@protoc_insertion_point(field_get:google.identity.accesscontextmanager.v1.OsConstraint.require_verified_chrome_os)
  return require_verified_chrome_os_;
}
inline void OsConstraint::set_require_verified_chrome_os(bool value) {
  
  require_verified_chrome_os_ = value;
  // @@protoc_insertion_point(field_set:google.identity.accesscontextmanager.v1.OsConstraint.require_verified_chrome_os)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace accesscontextmanager
}  // namespace identity
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction>() {
  return ::google::identity::accesscontextmanager::v1::BasicLevel_ConditionCombiningFunction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_google_2fidentity_2faccesscontextmanager_2fv1_2faccess_5flevel_2eproto
